/*

:binary
:boolean
:date
:datetime
:decimal
:float
:integer
:bigint
:primary_key
:references
:string
:text
:time
:timestamp

*/

// version 0.0.5
class EntityModel {
    
    constructor(name){
        this.obj = {
            name: name,
            type: null,
            relationshipType: null,
            typeSize : null,
            primary : null,
            default : null,
            virtual : null,
            foreignKey : null,
            nullable : true, // no
            unique : false,
            auto : false,
            cascadeOnDelete : true,
            lazyLoading : true,
            isNavigational : false,
            skipGetFunction :false,
            valueConversion : true
            
        }
    }

    type(type, size){
        this.obj.type = type;
        this.obj.typeSize = size;
        return this;
    }

    string(){
        this.obj.type = "string";
        return this;
    }

    integer(){
        this.obj.type = "integer";
        return this;
    }

    time(){
        this.obj.type = "time";
        return this;
    }

    boolean(){
        this.obj.type = "boolean";
        return this;
    }

    // maxLength(amount){
    //     this.obj.maxLength = amount;
    //     return this;
    // }

    // will stop cascade delete which means it will stop not auto delete relationship
    stopCascadeOnDelete(){
        this.obj.cascadeOnDelete = false;
        return this;
    }
    
    // is this obj a primary key
    primary(){
        this.obj.primary = true;
        this.obj.nullable = false;
        this.obj.unique = true;
        return this;
    }
    
    // allows ablity to get back primaryKey on insert automaticlly return on insert
    auto(){
        this.obj.auto = true;
        return this;
    }

    // sets the default value in the DB
    default(value){
        this.obj.default = value;
        return this;
    }

    get(func){
        this.obj.get = func;
        return this;
    }

    set(func){
        this.obj.set = func;
        return this;
    }

    unique(){
        this.obj.unique = true; // yes
        return this; 

    }

    // this means that it can be an empty field
    nullable(){
        this.obj.nullable = true; // yes
        return this; 
    }

    notNullable(){
        this.obj.nullable = false; // no
        return this; 
    }

    //allows you to stop lazy loading because lazy loading is added by default
    lazyLoadingOff(){
        this.obj.lazyLoading = false;
        return this;
    }

    valueConversion(bool){
        this.obj.valueConversion = bool;
        return this;
    }

    // allows you to add a virtual object that will skipped from being used as sql objects
    virtual(){
        this.obj.virtual = true;
        return this;
    }

    hasMany(foreignTable, foreignKey){
        if(foreignKey === undefined){
            foreignKey = `${this.obj.name.toLowerCase()}_id`;
        }
        this.obj.relationshipType = "hasMany";
        this.obj.type = "hasMany";
        this.obj.foreignTable = foreignTable;
        this.obj.foreignKey = foreignKey;
        this.obj.isNavigational = true;
        this.obj.nullable = false;
        return this;
    }

    // DB must have a record or exception will be thrown unless set to nullable
    hasOne(foreignTable, foreignKey){
        if(foreignKey === undefined){
            foreignKey = `${this.obj.name.toLowerCase()}_id`;
        }
        this.obj.relationshipType = "hasOne";
        this.obj.type = "hasOne";
        this.obj.foreignTable = foreignTable;
        this.obj.foreignKey = foreignKey;
        this.obj.isNavigational = true;
        this.obj.nullable = false;
        return this;
    }

// will do a inner join with foreignKey 
    //hasManyThrough("Tagging", "tag_id") ----- if foreignKey is not provided use the name of the object_id
    hasManyThrough(foreignTable,  foreignKey ){
        if(foreignKey === undefined){
            foreignKey = `${this.obj.name.toLowerCase()}_id`;
        };
        this.obj.relationshipType = "hasManyThrough";
        this.obj.type = "hasManyThrough";
        this.obj.foreignTable = foreignTable;// if joinKey is undefined then use name of object. 
        this.obj.foreignKey = foreignKey; // Foreign Key table
        this.obj.isNavigational = true;
        return this;
    }

    // will get info
    belongsTo(foreignTable, foreignKey){

        if(foreignKey === undefined){
            foreignKey = `${foreignTable.toLowerCase()}_id`;
        }
        // will use table name to find forien key
        this.obj.type = "integer";
        this.obj.relationshipType = "belongsTo";
        
        this.obj.foreignTable = foreignTable; // this is the table name of the current table if diffrent from the object name
        this.obj.foreignKey = foreignKey; // this is the table name of the joining table
        this.obj.nullable = false; // this means it cannot be null
        return this
    }

    foreignKey(foreignKey){
        this.obj.foreignKey = foreignKey;
        this.obj.nullable = false;
        return this
    }

    foreignTable(foreignTable){
        this.obj.foreignTable = foreignTable;
        this.obj.nullable = false;
        return this
    }
}
module.exports = EntityModel;
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/Entity/entityModel.js **
// version 0.0.3

var modelDB  = require('./entityModel');

// creates new instance if entity model and calls inner functions to build out a valid entity
class EntityModelBuilder {

    static create(model){
        if(model.name === undefined){
            throw "dbset model declaired incorrectly. Check you dbset models for code errors."
        }
        var mod = new model(); //create new instance of Entity Model
        var obj = {};
        var methodNamesArray = Object.getOwnPropertyNames( mod.__proto__ );
        var constructorIndex = methodNamesArray.indexOf("constructor");
        // remove contructor method
        if (constructorIndex > -1) {
            methodNamesArray.splice(constructorIndex, 1);
        }
        // loop through all method names in the entity model
        for (var i = 0; i < methodNamesArray.length; i++) {
            let MDB = new modelDB(model.name); // create a new instance of entity Model class
            mod[methodNamesArray[i]](MDB);
            this.cleanNull(MDB.obj); // remove objects that are null or undefined
            if(Object.keys(MDB.obj).length === 0){
                MDB.obj.virtual = true;
            }
            MDB.obj.name = methodNamesArray[i];
            obj[methodNamesArray[i]] = MDB.obj;
        }
        return obj;
    }

    static cleanNull(obj) {
        for (var propName in obj) { 
          if (obj[propName] === null) {
            delete obj[propName];
          }
        }
    }

}

module.exports = EntityModelBuilder;
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/Entity/entityModelBuilder.js **

// version : 0.0.7
var tools =  require('../Tools');
class EntityTrackerModel {


    // entity states https://docs.microsoft.com/en-us/dotnet/api/system.data.entitystate?view=netframework-4.7.2

    // start tracking model
    build(dataModel, currentEntity, context){
        var $that = this;
        var modelClass = this.buildObject(); // build entity with models
        modelClass.__proto__ = {};
        const modelFields = Object.entries(dataModel); /// return array of objects
        modelClass.__entity = currentEntity;
        modelClass.__name = currentEntity.__name;
        modelClass.__context = context;
        this.buildRelationshipModels(modelClass, currentEntity, dataModel);
        
        // loop through data model fields
        for (const [modelField, modelFieldValue] of modelFields) { 
            
            // set the value dynamiclly
            if(!$that._isRelationship(currentEntity[modelField])){
                // current entity has a value then add
                modelClass["__proto__"]["_" + modelField] = modelFieldValue;

                Object.defineProperty(modelClass,modelField, {
                    set: function(value) {
                        modelClass.__state = "modified";
                        modelClass.__dirtyFields.push(modelField);
                        if(typeof currentEntity[modelField].set === "function"){
                            this["__proto__"]["_" + modelField] = currentEntity[modelField].set(value);
                        }else{
                            // Then it will add name to dirty fields
                            this["__proto__"]["_" + modelField] = value;
                        }
                    },
                    get:function(){
                        // TODO: fix only when updating
                        if(currentEntity[modelField]){
                            if(!currentEntity[modelField].skipGetFunction){
                                if(typeof currentEntity[modelField].get === "function"){
                                    return currentEntity[modelField].get(this["__proto__"]["_" + modelField]);
                                }else{
                                    return this["__proto__"]["_" + modelField];
                                }
                            }
                        }else{
                            return this["__proto__"]["_" + modelField];
                        }
                    }
                  });
            }   
        }
        
      
        return modelClass;
    }

    buildObject(){
        return {
            __ID : Math.floor((Math.random() * 100000) + 1),
            __dirtyFields : [],
            __state : "track",
            __entity : null,
            __context : null,
            __name : null
        }
    }

    _isRelationship(entity){
        if(entity){
            if(entity.type === "hasOne" || entity.type === "hasMany" || entity.relationshipType === "belongsTo" || entity.type === "hasManyThrough"){ 
                return true;
            }
            else{
                return false;
            }
        }else{
            return false;
        }
    }

    buildRelationshipModels(modelClass, currentEntity, currentModel){
        var $that = this;
        // loop though current entity and add only relationship models to this list
        const entityFields = Object.entries(currentEntity); 
        for (const [entityField, entityFieldValue] of entityFields) { // loop through entity values
          
            if($that._isRelationship(currentEntity[entityField])){ 
 
                
                Object.defineProperty(modelClass, entityField, {
                    set: function(value) {
                        if(typeof value === "string" || typeof value === "number" || typeof value === "boolean"  || typeof value === "bigint" ){
                            modelClass.__state = "modified";
                            modelClass.__dirtyFields.push(entityField);
                             modelClass.__context.__track(modelClass);
                        }
                        this["__proto__"]["_" + entityField] = value;
                    },
                    get : function(){
                        var ent = tools.findEntity(entityField, this.__context);
                        if(!ent){
                            var parentEntity = tools.findEntity(this.__name, this.__context);
                            if(parentEntity){
                                ent = tools.findEntity(parentEntity.__entity[entityField].foreignTable, this.__context);
                                if(!ent){
                                    return  `Error - Entity ${parentEntity.__entity[entityField].foreignTable} not found. Please check your context for proper name.`
                                }
                            }
                            else{
                                return  `Error - Entity ${parentEntity} not found. Please check your context for proper name.`
                            }
                        }
    
                        
                        if(currentEntity[entityField].relationshipType === "belongsTo"){
                            if(currentEntity[entityField].lazyLoading){
                                 // TODO: UPDATE THIS CODE TO USE SOMETHING ELSE - THIS WILL NOT WORK WHEN USING DIFFERENT DATABASES BECAUSE THIS IS USING SQLITE CODE. 
                            
                                 var name = currentEntity[entityField].foreignKey;
                                 var priKey = tools.getPrimaryKeyObject(ent.__entity);
     
                                 //var idValue = currentEntity[entityField].foreignKey;
                                 var currentValue = this.__proto__[`_${name}`];
                                 var val = this["__proto__"]["_"+entityField];
                                 var modelValue = null;
                                 if(!val){
                                    modelValue = ent.where(`r => r.${priKey} == ${ currentValue }`).single();
                                     
                                 }
                                 else{
                                    modelValue = val;
                                 }
     
                                 this[entityField] = modelValue;
                            }
                            else{
                                return this["__proto__"]["_" + entityField];
                            }
                        }
                        else{
                            // user.tags = gets all tags related to user
                            // tag.users = get all users related to tags
                            if(currentEntity[entityField].lazyLoading){
                                var priKey = tools.getPrimaryKeyObject(this.__entity);
                                var entityName = currentEntity[entityField].foreignTable === undefined ? entityField : currentEntity[entityField].foreignTable;
                                var tableName = "";
                                if(entityName){
                                    switch(currentEntity[entityField].type){
                                        // TODO: move the SQL generation part to the SQL builder so that we can later on use many diffrent types of SQL databases. 
                                        case "hasManyThrough" :
                                            try{
                                                var joiningEntity = this.__context[tools.capitalize(entityName)];
                                                var entityFieldJoinName = currentEntity[entityField].foreignTable === undefined? entityField : currentEntity[entityField].foreignTable;
                                                var thirdEntity = this.__context[tools.capitalize(entityFieldJoinName)];
                                                var firstJoiningID = joiningEntity.__entity[this.__entity.__name].foreignTable;
                                                var secondJoiningID = joiningEntity.__entity[entityField].foreignTable;
                                                if(firstJoiningID && secondJoiningID )
                                                {
                                                    var modelValue = ent.include(`p => p.${entityFieldJoinName}.select(j => j.${joiningEntity.__entity[this.__entity.__name].foreignKey})`).include(`p =>p.${this.__entity.__name}`).where(`r =>r.${this.__entity.__name}.${priKey} = ${this[priKey]}`).toList();
                                                    // var modelQuery = `select ${selectParameter} from ${this.__entity.__name} INNER JOIN ${entityName} ON ${this.__entity.__name}.${priKey} = ${entityName}.${firstJoiningID} INNER JOIN ${entityField} ON ${entityField}.${joinTablePriKey} = ${entityName}.${secondJoiningID} WHERE ${this.__entity.__name}.${priKey} = ${ this[priKey]}`;
                                                    // var modelValue = ent.raw(modelQuery).toList();
                                                    this[entityField] = modelValue;
                                                }
                                                else{
                                                    return "Joining table must declaire joining table names"
                                                }
                                            }
                                            catch(error){
                                                return error;
                                            }
                                        /*
                                        select * from User 
                                        INNER JOIN Tagging ON User.id = Tagging.user_id
                                        INNER JOIN Tag ON Tag.id = Tagging.tag_id
                                        WHERE Tagging.user_id = 13
                                        */
                                        break;
                                        case "hasOne" : 
                                            var entityName = tools.findForeignTable(this.__entity.__name, ent.__entity);
                                            if(entityName){
                                                tableName = entityName.foreignKey;
                                            }
                                            else{
                                                return `Error - Entity ${ent.__entity.__name} has no property named ${this.__entity.__name}`;
                                            }
    
                                            //var jj = ent.raw(`select * from ${entityName} where ${tableName} = ${ this[priKey] }`).single();
                                            var modelValue = ent.where(`r => r.${tableName} == ${this[priKey]}`).single();
                                            this[entityField] = modelValue;
                                        break;
                                        case "hasMany" : 
                                            var entityName = tools.findForeignTable(this.__entity.__name, ent.__entity);
                                            if(entityName){
                                                tableName = entityName.foreignKey;
                                            }
                                            else{
                                                return  `Error - Entity ${ent.__entity.__name} has no property named ${this.__entity.__name}`;
                                            }
                                            //var modelValue = ent.raw(`select * from ${entityName} where ${tableName} = ${ this[priKey] }`).toList();
                                            var modelValue = ent.where(`r => r.${tableName} == ${this[priKey]}`).toList();
                                            this[entityField] = modelValue;
                                        break;
                                    }
                                }
                                else{
                                    return  "Entity name must be defined"
                                }
                            }
                            else{
                                return this["__proto__"]["_" + entityField];
                            }
                        }
                        
                        
                        return this["__proto__"]["_" + entityField];
                    }
                  });

                if(currentEntity[entityField].relationshipType === "belongsTo"){
                    // check if entity has a value if so then return that value
                    if(currentModel[entityField]){
                        modelClass[entityField] = currentModel[entityField];
                    }
                }
               
            }
        
        }
    }

}

module.exports = EntityTrackerModel
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/Entity/entityTrackerModel.js **

// https://github.com/kriasoft/node-sqlite
// https://www.learnentityframeworkcore.com/dbset/deleting-data
// version 1.0.20
var context = require("./context");
var schema = require("./Migrations/schema");

class masterrecord{

    constructor(){
        this.context = context;
        this.schema = schema;
    }
}


module.exports = new masterrecord();



/*

//Create new standard
var standard = new Standard();
standard.StandardName = "Standard1";

//create three new teachers
var teacher1 = new Teacher();
teacher1.TeacherName = "New Teacher1";

var teacher2 = new Teacher();
teacher2.TeacherName = "New Teacher2";

var teacher3 = new Teacher();
teacher3.TeacherName = "New Teacher3";

//add teachers for new standard
standard.Teachers.Add(teacher1);
standard.Teachers.Add(teacher2);
standard.Teachers.Add(teacher3);

using (var dbCtx = new SchoolDBEntities())
{
    //add standard entity into standards entitySet
    dbCtx.Standards.Add(standard);
    //Save whole entity graph to the database
    dbCtx.SaveChanges();
}
*/

** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/MasterRecord.js **
#!/usr/bin/env node

// version 0.0.4
// https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/migrations/
// how to add environment variables on cli call example - master=development masterrecord add-migration auth authContext

const program = require('commander');
let fs = require('fs');
let path = require('path');
var Migration = require('./migrations');
var globSearch = require("glob");


const [,, ...args] = process.argv



program
  .version('0.0.3', '-v, --version', '0.0.3')
  .description('A ORM framework that facilitates the creation and use of business objects whose data requires persistent storage to a database');

  // Instructions : to run command you must go to main project folder is located and run the command using the context file name.
  program
  .command('enable-migrations <contextFileName>')
  .alias('em')
  .description('Enables the migration in your project by creating a configuration class called ContextSnapShot.json')
  .action(function(contextFileName){

        var migration = new Migration();
        // location of folder where command is being executed..
        var executedLocation = process.cwd();
        // find context file from main folder location
        var contextInstance = migration.findContext(executedLocation, contextFileName);
       var context =  new contextInstance.context();
        var snap = {
          file : contextInstance.fileLocation,
          executedLocation : executedLocation,
          context : context,
          contextEntities : [],
          contextFileName: contextFileName.toLowerCase()
        }

        migration.createSnapShot(snap);
        console.log("Migration enabled")

  });

  // program
  // .command('create-database <contextFileName> <dbName>')
  // .alias('cd')
  // .description('allows you to create a database')
  // .action(function(contextFileName, dbName){
  //     var executedLocation = process.cwd();
  //     contextFileName = contextFileName.toLowerCase();
          
  //     try{
  //        // find context file from main folder location
  //        // find context file from main folder location
  //        var search = `${executedLocation}/**/*${contextFileName}_contextSnapShot.json`;
  //        var files = globSearch.sync(search, executedLocation);
  //        var file = files[0];

  //        if(file){
  //           var contextSnapshot = require(file);
  //           var context = require(contextSnapshot.contextLocation);
  //           var newSchema = new schema(context);
  //           newSchema.createDatabase(dbName);
  //        }
  //        else{
  //          console.log("Error - Cannot read or find Context file");
  //         }


  //       }catch (e){
  //         console.log("Error - Cannot read or find file ", e);
  //       }
  //       console.log("Database Created");

  // });


  // Instructions : to run command you must go to folder where migration file is located.
  program
  .command('add-migration <name> <contextFileName>')
  .alias('am')
  .action(function(name, contextFileName){
    var executedLocation = process.cwd();
    contextFileName = contextFileName.toLowerCase();
    var migration = new Migration();
      try{
          // find context file from main folder location
        var search = `${executedLocation}/**/*${contextFileName}_contextSnapShot.json`;
        var files = globSearch.sync(search, executedLocation);
        var file = files[0];
        if(file){
          var contextSnapshot = require(files[0]);
          var context = require(contextSnapshot.contextLocation);
          var contextInstance = new context();
          var cleanEntities = migration.cleanEntities(contextInstance.__entities);
          var newEntity = migration.template(name, contextSnapshot.schema, cleanEntities);
          var migrationDate = Date.now();
          var file = `${contextSnapshot.migrationFolder}/${migrationDate}_${name}_migration.js`
          fs.writeFile(file, newEntity, 'utf8', function (err) {
            if (err) return console.log("--- Error running cammand, re-run command add-migration ---- ", err);
          });
          console.log(`${name} migration file created`);
        }
        else{
          console.log("Error - Cannot read or find Context file");
        }
       }catch (e){
         console.log("Error - Cannot read or find file ", e);
      }
  });

 program
  .command('update-database <contextFileName>')
  .alias('ud')
  .description('Apply pending migrations to database - up method call')
  .action(function(contextFileName){
    var executedLocation = process.cwd();
    contextFileName = contextFileName.toLowerCase();
    var migration = new Migration();
      try{
         // find context file from main folder location
         var search = `${executedLocation}/**/*${contextFileName}_contextSnapShot.json`;
         var files = globSearch.sync(search, executedLocation);
         var file = files[0];
         if(file){
          var contextSnapshot = require(file);
          var searchMigration = `${contextSnapshot.migrationFolder}/**/*_migration.js`;
          var migrationFiles = globSearch.sync(searchMigration, contextSnapshot.migrationFolder);
          if( migrationFiles){
            
           // find newest migration file
           // THIS DOESNT WORK BUG - hack to fix this I just take the last file which I am asuming is the newest one
             var mFiles = migrationFiles.sort(function(x, y){
               return new Date(x.timestamp) < new Date(y.timestamp) ? 1 : -1
             });
          /** ENd of BUG */
          
             var mFile = mFiles[mFiles.length -1];

             var migrationProjectFile = require(mFile);
             var context = require(contextSnapshot.contextLocation);
             var contextInstance = new context();
             var newMigrationProjectInstance = new migrationProjectFile(context);

             var tableObj = migration.buildUpObject(contextSnapshot.schema, contextInstance.__entities);
             
             var cleanEntities = migration.cleanEntities(contextInstance.__entities);
             newMigrationProjectInstance.up(tableObj);
            
             var snap = {
               file : contextSnapshot.contextLocation,
               executedLocation : executedLocation,
               context : contextInstance,
               contextEntities : cleanEntities,
               contextFileName: contextFileName
             }
 
             migration.createSnapShot(snap);
             console.log("database updated");
          }
          else{
           console.log("Error - Cannot read or find migration file");
          }

         }
         else{
           console.log("Error - Cannot read or find Context file");
          }
        }catch (e){
          console.log("Error - Cannot read or find file ", e);
        }
  });


  program
  .command('update-database-restart <contextFileName>')
  .alias('udr')
  .description('Apply pending migrations to database - up method call')
  .action(function(contextFileName){
    var executedLocation = process.cwd();
    contextFileName = contextFileName.toLowerCase();
    var migration = new Migration();
      try{
         // find context file from main folder location
         var search = `${executedLocation}/**/*${contextFileName}_contextSnapShot.json`;
         var files = globSearch.sync(search, executedLocation);
         var file = files[0];
         if(file){
          var contextSnapshot = require(file);
          var searchMigration = `${contextSnapshot.migrationFolder}/**/*_migration.js`;
          var migrationFiles = globSearch.sync(searchMigration, contextSnapshot.migrationFolder);
          if( migrationFiles){
            
          
            // organize by time
            var mFiles = migrationFiles.sort(function(x, y){
              return new Date(x.timestamp) < new Date(y.timestamp) ? 1 : -1;
            });
             var context = require(contextSnapshot.contextLocation);
             
             for (let i = 0; i < mFiles.length; i++) {
                var file = mFiles[i];
                var migrationProjectFile = require(file);

                var contextInstance = new context();
                var newMigrationProjectInstance = new migrationProjectFile(context);
                var tableObj = migration.buildUpObject(contextSnapshot.schema, contextInstance.__entities);
                var cleanEntities = migration.cleanEntities(contextInstance.__entities);
                newMigrationProjectInstance.up(tableObj);
            }
        
            
            var snap = {
                  file : contextSnapshot.contextLocation,
                  executedLocation : executedLocation,
                  context : contextInstance,
                  contextEntities : cleanEntities,
                  contextFileName: contextFileName
                }
 
             migration.createSnapShot(snap);
             console.log("database updated");
          }
          else{
           console.log("Error - Cannot read or find migration file");
          }

         }
         else{
           console.log("Error - Cannot read or find Context file");
          }
        }catch (e){
          console.log("Error - Cannot read or find file ", e);
        }
  });


 program
 .command('get-migrations <contextFileName>')
 .alias('gm')
 .description('Get a list of migration file names using the context')
 .action(function(contextFileName){
      var executedLocation = process.cwd();
      contextFileName = contextFileName.toLowerCase();
      var search = `${executedLocation}/**/*${contextFileName}_contextSnapShot.json`;
      var files = globSearch.sync(search, executedLocation);
      var file = files[0];
      if(file){
          var contextSnapshot = require(file);
          var searchMigration = `${contextSnapshot.migrationFolder}/**/*_migration.js`;
          var migrationFiles = globSearch.sync(searchMigration, contextSnapshot.migrationFolder);
          if( migrationFiles){
            return migrationFiles;
          }
      }
      else{
        console.log("Error - Cannot read or find Context file");
      }
 });

  // we will find the migration folder inside the nearest app folder if no migration folder is location is added
  program
  .command('update-database-target <migrationFileName>')
  .alias('udt')
  .description('Apply pending migrations to database - down method call')
  .action(function(migrationFileName){
  // this will call all the down methods until it gets to the one your looking for. First it needs to validate that there is such a file.
  // TODO:
  
  });



program.parse(process.argv);
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/Migrations/cli.js **

// verison 0.0.2
class migrationMySQLQuery {

    #tempTableName = "_temp_alter_column_update"
    
    #getTableColumns(table){
        var columnList = [];
        for (var key in table) {
            if(typeof table[key] === "object"){
                columnList.push(table[key].name);
            }
        }
        return columnList.join(',');;
    }

    #columnMapping(table){
        /*
        var mapping = {
            "name": "id", // if this changes then call rename column
            "type": "integer", // if this changes then call altercolumn 
            "primary": false, // is primary key 
            "nullable": false, // is nullable 
            "unique": true, // vlaue has to be uniqe
            "auto": true, // sets the value to AUTOINCREMENT
            "cascadeOnDelete": true,
            "lazyLoading": true,
            "isNavigational": false
        
        }
        */
        // name TEXT NOT NULL,

        var auto = table.auto ? " AUTO_INCREMENT":"";
        var primaryKey = table.primary ? " PRIMARY KEY" : "";
        var nullName = table.nullable ? "" : " NOT NULL";
        var unique = table.unique ? " UNIQUE" : "";
        var type = this.typeManager(table.type);
        var tableName = table.name;
        var defaultValue  = "";
        if(table.default != null){

            defaultValue = ` DEFAULT ${this.boolType(table.default)}`
        }
        if(table.relationshipType === 'belongsTo'){
            tableName = table.foreignKey;
        }

        return `${tableName} ${type}${nullName}${defaultValue}${unique}${primaryKey}${auto}`;
    }

    boolType(type){
        switch(type) {
            case "true":
                return "1"
              break;
              case "false":
                return "0"
              break;
              case true:
                return "1"
              break;
              case false:
                return "0"
              break;
              default:
                return type;
        }
    }

    typeManager(type){
        switch(type) {
            case "string":
                return "VARCHAR(255)"
              break;
            case "text":
                return "TEXT"
              break;
            case "float":
                return "fLOAT(24)"
              break;
            case "decimal":
                return "DECIMAL"
              break;
            case "datetime":
                return "DATETIME"
              break;
            case "timestamp":
                return "TIMESTAMP"
              break;
            case "date":
                return "DATE"
              break;
            case "time":
                return "TIME"
              break;
            case "boolean":
                return "TINYINT"
              break;
            case "integer":
                return "INTEGER"
              break;
            case "binary":
                return "BLOB"
              break;
            case "blob":
                return "BLOB"
              break;
            case "json":
                return "JSON"
              break;
          }
          // :string, :text, :integer, :float, :decimal, :datetime, :timestamp, :time, :date, :binary, :boolean
    }  

    // table is the altered field
    alterColumn( table){
      
        if(table){

            return `ALTER TABLE ${table.tableName} MODIFY COLUMN ${this.#columnMapping(table.table)} `;
        }
        else{
            console.log("table information is null");
            return null;
        }
    }

    alterNullable(table){
        // check if has value
        if(typeof table.changes.nullable !== 'undefined'){
            // if it does we want to add that to the alter statment
        }
    }


    addColum(table){
        return `ALTER TABLE ${table.tableName}
        ADD ${table.name} ${table.realDataType}`;

        /*
            column definations
            NULL
            TEXT. The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16LE).
            BLOB. The value is a blob of data, stored exactly as it was input
            INTEGER,
            real
        */
    }

    dropColumn(table){
        /*
        COLUMNS CANNOT BE DROPPED - RULES
        has unique constraint
        is indexed
        appears in a view
        */
        return `ALTER TABLE ${table.tableName} DROP COLUMN ${table.name}`;
    }

    insertInto(name, table){
        return `INSERT INTO ${name} (${this.#getTableColumns(table)})
        SELECT ${this.#getTableColumns(table)} FROM ${this.#tempTableName}`;
    }

    createTable(table){

        var queryVar = "";
        //console.log("Dsfdsfdsf---------", table)
        for (var key in table) {
            if(typeof table[key] === "object"){

                if(table[key].type !== "hasOne" && table[key].type  !== "hasMany" && table[key].type  !== "hasManyThrough"){
                    queryVar += `${this.#columnMapping(table[key])}, `;
                }
            }
        }

        var completeQuery = `CREATE TABLE ${table.__name} (${queryVar.replace(/,\s*$/, "")});`;
        return completeQuery;

            /*
                INTEGER PRIMARY KEY AUTOINCREMENT
                    all these are equal to interger
                INT
                INTEGER
                TINYINT
                SMALLINT
                MEDIUMINT
                BIGINT
                UNSIGNED BIG INT
                INT2
                INT8 
            */
    }


    dropTable(name){
        return `DROP TABLE ${name}`
    }

    renameTable(table){
        return `ALTER TABLE ${table.tableName} RENAME TO ${table.newName}`;
    }

    renameColumn(table){
        return `ALTER TABLE ${table.tableName} RENAME COLUMN ${table.name} TO ${table.newName}`
    }

    
}


module.exports = migrationMySQLQuery; 

/**
 * 
 * 
 * 
 * 
MySQL Data Types NATIVE_DATABASE_TYPES = {
        primary_key: "bigint auto_increment PRIMARY KEY",
        string:      { name: "varchar", limit: 255 },
        text:        { name: "text" },
        integer:     { name: "int", limit: 4 },
        float:       { name: "float", limit: 24 },
        decimal:     { name: "decimal" },
        datetime:    { name: "datetime" },
        timestamp:   { name: "timestamp" },
        time:        { name: "time" },
        date:        { name: "date" },
        binary:      { name: "blob" },
        blob:        { name: "blob" },
        boolean:     { name: "tinyint", limit: 1 },
        json:        { name: "json" },
      }


PostgreSQL Data Types NATIVE_DATABASE_TYPES = {
        primary_key: "bigserial primary key",
        string:      { name: "character varying" },
        text:        { name: "text" },
        integer:     { name: "integer", limit: 4 },
        float:       { name: "float" },
        decimal:     { name: "decimal" },
        datetime:    {}, # set dynamically based on datetime_type
        timestamp:   { name: "timestamp" },
        timestamptz: { name: "timestamptz" },
        time:        { name: "time" },
        date:        { name: "date" },
        daterange:   { name: "daterange" },
        numrange:    { name: "numrange" },
        tsrange:     { name: "tsrange" },
        tstzrange:   { name: "tstzrange" },
        int4range:   { name: "int4range" },
        int8range:   { name: "int8range" },
        binary:      { name: "bytea" },
        boolean:     { name: "boolean" },
        xml:         { name: "xml" },
        tsvector:    { name: "tsvector" },
        hstore:      { name: "hstore" },
        inet:        { name: "inet" },
        cidr:        { name: "cidr" },
        macaddr:     { name: "macaddr" },
        uuid:        { name: "uuid" },
        json:        { name: "json" },
        jsonb:       { name: "jsonb" },
        ltree:       { name: "ltree" },
        citext:      { name: "citext" },
        point:       { name: "point" },
        line:        { name: "line" },
        lseg:        { name: "lseg" },
        box:         { name: "box" },
        path:        { name: "path" },
        polygon:     { name: "polygon" },
        circle:      { name: "circle" },
        bit:         { name: "bit" },
        bit_varying: { name: "bit varying" },
        money:       { name: "money" },
        interval:    { name: "interval" },
        oid:         { name: "oid" },
      }
 */


      /****
       * 
       * 
       * console.log("sdfdsfdsf", this.#tempTableName);
        return `ALTER TABLE ${table.tableName} MODIFY COLUMN NOT NULL`
        TODO -- We need to find a way build the alter query based on the data that is changed
        //ALTER TABLE MyTable MODIFY COLUMN comment BIGINT NOT NULL;
        if(table){
            table.newName = this.#tempTableName;
            //console.log("----------------------", table)
            return {
                1 : this.renameTable(table),
                2 : this.createTable(fullTable),
                3 : this.insertInto(table.tableName, fullTable),
                4 : this.dropTable(this.#tempTableName)
            }
        }
        else{
            console.log("table information is null")
        }
       */
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/Migrations/migrationMySQLQuery.js **

// verison 0.0.5
class migrationSQLiteQuery {

    #tempTableName = "_temp_alter_column_update"
    
    #getTableColumns(table){
        var columnList = [];
        for (var key in table) {
            if(typeof table[key] === "object"){
                columnList.push(table[key].name);
            }
        }
        return columnList.join(',');;
    }

    #columnMapping(table){
        /*
        var mapping = {
            "name": "id", // if this chnages then call rename column
            "type": "integer", // if this changes then call altercolumn 
            "primary": false, // is primary key 
            "nullable": false, // is nullable 
            "unique": true, // vlaue has to be uniqe
            "auto": true, // sets the value to AUTOINCREMENT
            "cascadeOnDelete": true,
            "lazyLoading": true,
            "isNavigational": false
        
        }
        */
        // name TEXT NOT NULL,

        var auto = table.auto ? " AUTOINCREMENT":"";
        var primaryKey = table.primary ? " PRIMARY KEY" : "";
        var nullName = table.nullable ? "" : " NOT NULL";
        var unique = table.unique ? " UNIQUE" : "";
        var type = this.#typeManager(table.type);

        return `${table.name} ${type}${nullName}${unique}${primaryKey}${auto}`;
    }

    #typeManager(type){
        switch(type) {
            case "string":
                return "TEXT"
              break;
            case "time":
                return "TEXT"
              break;
              case "boolean":
                return "INTEGER"
              break;
              case "integer":
                return "INTEGER"
              break;
          }
          
    }  

    alterColumn(fullTable, table){
        if(table){
            table.newName = this.#tempTableName;
            return {
                1 : this.renameTable(table),
                2 : this.createTable(fullTable),
                3 : this.insertInto(table.tableName, fullTable),
                4 : this.dropTable(this.#tempTableName)
            }
        }
        else{
            console.log("table information is null")
        }
    }


    addColum(table){
        return `ALTER TABLE ${table.tableName}
        ADD COLUMN ${table.name}`;

        /*
            column definations
            NULL
            TEXT. The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16LE).
            BLOB. The value is a blob of data, stored exactly as it was input
            INTEGER,
            real
        */
    }

    dropColumn(table){
        /*
        COLUMNS CANNOT BE DROPPED - RULES
        has unique constraint
        is indexed
        appears in a view
        */
        return `ALTER TABLE ${table.tableName} DROP COLUMN ${table.name}`
    }

    insertInto(name, table){
        return `INSERT INTO ${name} (${this.#getTableColumns(table)})
        SELECT ${this.#getTableColumns(table)} FROM ${this.#tempTableName}`;
    }

    createTable(table){
        var queryVar = "";
        for (var key in table) {
            if(typeof table[key] === "object"){
                queryVar += `${this.#columnMapping(table[key])}, `;
            }
        }
    
        return `CREATE TABLE ${table.__name} (${queryVar.replace(/,\s*$/, "")});`;

            /*
                INTEGER PRIMARY KEY AUTOINCREMENT
                    all these are equal to interger
                INT
                INTEGER
                TINYINT
                SMALLINT
                MEDIUMINT
                BIGINT
                UNSIGNED BIG INT
                INT2
                INT8 
            */
    }


    dropTable(name){
        return `DROP TABLE ${name}`
    }

    renameTable(table){
        return `ALTER TABLE ${table.tableName} RENAME TO ${table.newName}`;
    }

    renameColumn(table){
        return `ALTER TABLE ${table.tableName} RENAME COLUMN ${table.name} TO ${table.newName}`
    }

    
}


module.exports = migrationSQLiteQuery; 


/*
 ADDING NEW COLUMN SQLITE 
     There are some restrictions on the new column:
            The new column cannot have a UNIQUE or PRIMARY KEY constraint.
            If the new column has a NOT NULL constraint, you must specify a default value for the column other than a NULL value.
            The new column cannot have a default of CURRENT_TIMESTAMP, CURRENT_DATE, and CURRENT_TIME, or an expression.
            If the new column is a foreign key and the foreign key constraint check is enabled, the new column must accept a default value NULL.

*/

/*

DROPING A COLUMN SQLITE 
        Possible reasons why the DROP COLUMN command can fail include:

                The column is a PRIMARY KEY or part of one.
                The column has a UNIQUE constraint.
                The column is indexed.
                The column is named in the WHERE clause of a partial index.
                The column is named in a table or column CHECK constraint not associated with the column being dropped.
                The column is used in a foreign key constraint.
                The column is used in the expression of a generated column.
                The column appears in a trigger or view.

*/
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/Migrations/migrationSQLiteQuery.js **


// https://channel9.msdn.com/Blogs/EF/Migrations-Under-the-Hood
// version 0.0.3

const os = require('os');
class MigrationTemplate {

    constructor(name) {
        this.name = name;
    }

    #up = ''
    #down = ''

    get(){
        return ` 
         
var masterrecord = require('masterrecord');

class ${this.name} extends masterrecord.schema { 
    constructor(context){
        super(context);
    }

    up(table){
        this.init(table);
        ${this.#up}
    }

    down(table){
        this.init(table);
        ${this.#down}
    }
}
module.exports = ${this.name};
        `
    }

    alterColumn(type, name, parent){
        if(type === "up"){
            this.#up += os.EOL + `     this.alterColumn(table.${name});` 
        }
        else{
            this.#down += os.EOL + `     this.alterColumn(table.${name});` 
        }
    }
    createTable(type, name){
        if(type === "up"){
            this.#up += os.EOL + `     this.createTable(table.${name});` 
        }
        else{
            this.#down += os.EOL + `     this.createTable(table.${name});` 
        }
    }

    addColumn(type, name, parent){
        if(type === "up"){
            this.#up += os.EOL + `     this.addColumn(table.${name});`
        }
        else{
            this.#down += os.EOL + `     this.addColumn(table.${name});`
        }
    }
    //this.addColumn(table.${parent}.${name});`
   
    dropTable(type, name){
        if(type === "up"){
            this.#down += os.EOL + `    this.droptable(table.${name});`
        }
        else{
            this.#down += os.EOL + `    this.droptable(table.${name});`
        }
    }

    dropColumn(type, name, parent){
        if(type === "up"){
            this.#up += os.EOL + `     this.dropColumn(table.${name});`
        }
        else{
            this.#down += os.EOL + `     this.dropColumn(table.${name});`
        }
    }

}

module.exports = MigrationTemplate;


** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/Migrations/migrationTemplate.js **
// version 0.0.8
// learn more about seeding info -  https://www.pauric.blog/Database-Updates-and-Migrations-with-Entity-Framework/

var fs = require('fs');
var diff = require("deep-object-diff");
var MigrationTemplate = require("./migrationTemplate");
var globSearch = require("glob");

// https://blog.tekspace.io/code-first-multiple-db-context-migration/

// node masterrecord add-migration josh C:\Users\rbatista\Downloads\kollege\freshmen\app\models\context
class Migrations{

    #organizeSchemaByTables(oldSchema, newSchema){
            var tables = []
            if(oldSchema.length === 0){
                newSchema.forEach(function (item, index) {
                    var table = {
                        name: item["__name"],
                        new :item,
                        old : {},
                        newColumns : [],
                        newTables : [],
                        deletedColumns : [],
                        updatedColumns : []
                    }
                    tables.push(table);
                });
            }
            else{
                newSchema.forEach(function (item, index) {
                    var table = {
                        name: item["__name"],
                        old: null,
                        new :item,
                        newColumns : [],
                        newTables : [],
                        deletedColumns : [],
                        updatedColumns : []
                    }
                    
                    oldSchema.forEach(function (oldItem, index) {
                        var oldItemName = oldItem["__name"];
                        if(table.name === oldItemName){
                            table.old = oldItem;
                            tables.push(table);
                        }
                    });
    
                });
            }

            return tables;
    }

    #findDeletedColumns(tables){
            tables.forEach(function (item, index) {
                var deletedColumn = null;
                if(item.new && item.old){
                    Object.keys(item.old).forEach(function (key) {
                        var value = item.old[key].name;
                        deletedColumn = null;
                        Object.keys(item.new).forEach(function (newKey) {
                            var newValue = item.new[newKey].name;
                            if(value === newValue){
                                deletedColumn = value;
                            }
                        });
                        if(deletedColumn === null){
                            item.deletedColumns.push(value);
                        }
                    });
                }
            });
            return tables;
    }

    #findUpdatedColumns(tables){


        tables.forEach(function (item, index) {
           
            var UD = diff.updatedDiff(item.old, item.new);
            const isEmpty = Object.keys(UD).length === 0;
            if(!isEmpty){
                for (var key in UD) {
                    var tableChanges = {
                        changes : UD[key],
                        table : item.new[key],
                        tableName : item.name
                    };
                    item.updatedColumns.push(tableChanges);
                }
            }
           
        });
        return tables;
    }

    #findNewColumns(tables){
            tables.forEach(function (item, index) {
                if(item.new && item.old){
                    Object.keys(item.new).forEach(function (key) {
                        if(typeof item.new[key] === "object"){
                            var value = item.new[key].name;
                            var columnNotFound = false;
                            Object.keys(item.old).forEach(function (oldKey) {
                                if(typeof item.old[oldKey] === "object"){
                                    var oldValue = item.old[oldKey].name;
                                    if(value === oldValue){
                                        columnNotFound = true;
                                    }
                                }
                            });

                            if(columnNotFound === false){
                                // this means it did not find the column
                                
                                if(item.new[key].type !== "hasOne" && item.new[key].type !== "hasMany" && item.new[key].type !== "hasManyThrough"){
                                    // if you have to create a new table no need to create the columns
                                    if(item.newTables.length === 0){
                                        item.newColumns.push(value);
                                    }
                                
                                }
                            }
                        }
                        
                    });
                }
                else{
                    console.log("Table object has no old or new values");
                }
            });
            return tables;
    }

    #findNewTables(tables){
        // find new tables 
        tables.forEach(function (item, index) {
            if(item.new && item.old){
                    if(Object.keys(item.old).length === 0){
                        item.newTables.push(item);
                    }
            }else{
                console.log("Cannot find NEW or and Old Objects");
            }

        });
        return tables;
    }

    // build table to build new migration snapshot
    #buildMigrationObject(oldSchema, newSchema){

        var tables = this.#organizeSchemaByTables(oldSchema, newSchema);
        
        tables = this.#findNewTables(tables);
        tables = this.#findNewColumns(tables);
        tables = this.#findDeletedColumns(tables);
        tables = this.#findUpdatedColumns(tables);
        return tables;
    }



    findContext(executedLocation, contextFileName){
        var search = `${executedLocation}/**/*${contextFileName}.js`
        var files = globSearch.sync(search, executedLocation);
        var file = files[0];
        var context = require(file);
        return {
            context : context,
            fileLocation : file
            }
    }

    // remove hasMany and hasOne and hasManyThrough
    cleanEntities(entities){
        var newEntity = [];
        for (let i = 0; i < entities.length; i++) {
            var entity = entities[i];
            var newObj = {}

            for (let key in entity) {
                if (entity.hasOwnProperty(key)) {
              
                    if(entity[key].type !== "hasOne" && entity[key].type  !== "hasMany" && entity[key].type  !== "hasManyThrough"){
                        // if(entity[key].relationshipType == "belongsTo" ){
                        //     entity[key].name = entity[key].foreignKey;
                        // }
                        newObj[key] = entity[key];
                    }
                }
            }
            newEntity.push(newObj);
        }

        return newEntity;
    }

    createSnapShot(snap){
        
        var dbFolder = `${snap.executedLocation}/db`;
        if (!fs.existsSync(dbFolder)){
            fs.mkdirSync(dbFolder);
        }

        var migrationsDirectory = `${snap.executedLocation}/db/migrations`;
        if (!fs.existsSync(migrationsDirectory)){
            fs.mkdirSync(migrationsDirectory);
        }
    
        var content = {
            contextLocation: snap.file,
            migrationFolder: `${snap.executedLocation}/db/migrations`,
            snapShotLocation: `${snap.executedLocation}/db/migrations/${snap.contextFileName}_contextSnapShot.json`,
            schema : snap.contextEntities
        };
    
        const jsonContent = JSON.stringify(content, null, 2);
        try{
          // will replace the whole file if it exist
            fs.writeFileSync(`${migrationsDirectory}/${snap.contextFileName}_contextSnapShot.json`, jsonContent);
        }catch (e){
            console.log("Cannot write file ", e);
        }
    }

    // validate if schema has changed based on new and old
    buildUpObject(oldSchema, newSchema){
        var tableObj = {}
        var tables = this.#buildMigrationObject(oldSchema, newSchema);

        tables.forEach(function (item, index) {
                    // add new columns for table
                    var columnInfo = tables[index];
                    
                    item.newTables.forEach(function (column, ind) {
                        tableObj[item.name] = columnInfo.new;
                    });

                    item.newColumns.forEach(function (column, ind) {
                        columnInfo.new[column].tableName = item.name;
                        tableObj[column] = columnInfo.new[column];
                    });

                    item.deletedColumns.forEach(function (column, ind) {
                        columnInfo.old[column].tableName = item.name;
                        tableObj[column] = columnInfo.old[column];
                    });

                    item.updatedColumns.forEach(function (column, ind) {
                        tableObj[column.table.name] = column;
                    });

                    if(item.new === null){
                        columnInfo.old.tableName = item.name;
                        tableObj["new"] = columnInfo.old;
                    }
                
                    tableObj.___table = item;
                });
        return tableObj;
    }

    template(name, oldSchema, newSchema){
        var MT = new MigrationTemplate(name);
        var tables = this.#buildMigrationObject(oldSchema, newSchema);
    
        tables.forEach(function (item, index) {
            if(item.old === null){
                MT.createTable("up", column, item.name);
                MT.dropTable("down", column, item.name);
            }
            
            if(item.new === null){
                MT.dropTable("up", column, item.name);
                MT.createTable("down", column, item.name);
            }

            item.newTables.forEach(function (column, ind) {
                MT.createTable("up", item.name);
                MT.dropTable("down", item.name);
            });

            // add new columns for table
            item.newColumns.forEach(function (column, index) {
                MT.addColumn("up", column, item.name);
                MT.dropColumn("down", column, item.name);
            });

            item.deletedColumns.forEach(function (column, index) {
                MT.dropColumn("up", column, item.name);
                MT.addColumn("down",column, item.name);
            });

            item.updatedColumns.forEach(function (column, index) {
                const isEmpty = Object.keys(column).length === 0;
                if(!isEmpty){
                    MT.alterColumn("up", column.table.name, item.name);
                    MT.alterColumn("down", column.table.name, item.name);
                }
            });

        });

       return MT.get();
    }


}

module.exports = Migrations;
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/Migrations/migrations.js **
// version 0.0.4
class schema{

    constructor(context){
        this.context = new context();
    }


    init(table){
        if(table){
            this.fullTable = table.___table;
        }
    }
    
    // create obj to convert into create sql
    addColumn(table){
        // todo need to work on add column for mysql
        if(table){
            if(this.context.isSQLite){
                var sqliteQuery = require("./migrationSQLiteQuery");
                var queryBuilder = new sqliteQuery();
                var queryObj = queryBuilder.alterColumn(this.fullTable.new, table);
                for (var key in queryObj) {
                    var query = queryObj[key];
                    this.context._execute(query);
                }
            }

            if(this.context.isMySQL){
                var sqlquery = require("./migrationMySQLQuery");
                var queryBuilder = new sqlquery();
                table.realDataType = queryBuilder.typeManager(table.type);
                var query = queryBuilder.addColum(table);
                this.context._execute(query);
            }
        }

        // add column to database
    }

    dropColumn(table){
        if(table){
            if(this.fullTable){
                // drop column 
                if(this.context.isSQLite){
                    var sqliteQuery = require("./migrationSQLiteQuery");
                    var queryBuilder = new sqliteQuery();
                    var query = queryBuilder.dropColumn(table);
                    this.context._execute(query);
                }

                if(this.context.isMySQL){
                    var sqlquery = require("./migrationMySQLQuery");
                    var queryBuilder = new sqlquery();
                    var query = queryBuilder.dropColumn(table);
                    this.context._execute(query);
                }

            }else{
                console.log("Must call the addTable function.");
            }
        }
    }
    
    createTable(table){

        if(table){
            if(this.context.isSQLite){
                var sqliteQuery = require("./migrationSQLiteQuery");
                var queryBuilder = new sqliteQuery();
                var query = queryBuilder.createTable(table);
                this.context._execute(query);
            }

            if(this.context.isMySQL){
                var sqlquery = require("./migrationMySQLQuery");
                var queryBuilder = new sqlquery();
                var query = queryBuilder.createTable(table);
                this.context._execute(query);
            }
        }else{
            console.log("Table that your trying to create is undefined. PLease check if there are any changes that need to be made");
        }
    }


    dropTable(table){
        if(table){
            if(this.context.isSQLite){
                var sqliteQuery = require("./migrationSQLiteQuery");
                var queryBuilder = new sqliteQuery();
                var query = queryBuilder.dropTable(table.__name);
                this.context._execute(query);
            }

            if(this.context.isMySQL){
                var sqlquery = require("./migrationMySQLQuery");
                var queryBuilder = new sqlquery();
                var query = queryBuilder.dropTable(table.__name);
                this.context._execute(query);
            }
        }
    }


   //"dbo.People", "Location"
    alterColumn(table){
        if(table){
            if(this.fullTable){
                if(this.context.isSQLite){
                    var sqliteQuery = require("./migrationSQLiteQuery");
                    var queryBuilder = new sqliteQuery();
                    var queryObj = queryBuilder.alterColumn(this.fullTable.new, table);
                    for (var key in queryObj) {
                        var query = queryObj[key];
                        this.context._execute(query);
                    }
                }

                if(this.context.isMySQL){
                    var sqlquery = require("./migrationMySQLQuery");
                    var queryBuilder = new sqlquery();
                    var query = queryBuilder.alterColumn(table);
                    this.context._execute(query);
                }

            }else{
                console.log("Must call the addTable function.");
            }
        }
    }

    renameColumn(){
        // TODO
    }

    seed(){
        // TODO
    }
    
}


module.exports = schema;
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/Migrations/schema.js **

// version 0.0.13
var entityTrackerModel = require('masterrecord/Entity/entityTrackerModel');
var tools = require('masterrecord/Tools');
var queryScript = require('masterrecord/QueryLanguage/queryScript');

class queryMethods{

    constructor(entity, context) {
        this.__entity = entity;
        this.__context = context;
        this.__queryObject = new queryScript();
    }

    // build a single entity
    __singleEntityBuilder(dataModel){
        var $that = this;
        if(dataModel){
            var ent = new entityTrackerModel();
            var mod = ent.build(dataModel, $that.__entity, $that.__context);
            mod.__state = "track";
            $that.__context.__track(mod);
            return mod;
        }else{
            return null;
        }
    }

    // build multiple entities
    __multipleEntityBuilder(entityValue){
        var $that = this;
        var listArray = [];
        if(entityValue){
            for(let i = 0; i < entityValue.length; i++){
                listArray.push($that.__singleEntityBuilder(entityValue[i]));
             }
             return listArray;
        }else{
            return null;
        }
    }

    __reset(){
        this.__queryObject.reset();
    }


    // do join on two tables = inner join
    join(){

    }

    groupBy(){
        
    }

    // do join on two tables = inner join
    _____leftJoin(){

    }

    ______orderByCount(query,  ...args){
        var str = query.toString();
        if(args){
            for(let argument in args){
                var item = args[argument];
                str = str.replace("$$", item);
            }
        }
        this.__queryObject.orderByCount(str, this.__entity.__name);
        return this;
    }

    ______orderByCountDescending(query,  ...args){
        var str = query.toString();
        if(args){
            for(let argument in args){
                var item = args[argument];
                str = str.replace("$$", item);
            }
        }
        this.__queryObject.orderByCountDesc(str, this.__entity.__name);
        return this;
    }

    orderBy(query,  ...args){
        var str = query.toString();
        if(args){
            for(let argument in args){
                var item = args[argument];
                str = str.replace("$$", item);
            }
        }
        this.__queryObject.orderBy(str, this.__entity.__name);
        return this;
    }

    orderByDescending(query,  ...args){
        var str = query.toString();
        if(args){
            for(let argument in args){
                var item = args[argument];
                str = str.replace("$$", item);
            }
        }
        this.__queryObject.orderByDesc(str, this.__entity.__name);
        return this;
    }

    raw(query){
        this.__queryObject.raw(query);
        return this;
    }

    /* WHERE and AND work together its a way to add to the WHERE CLAUSE DYNAMICALLY */
    and(query,  ...args){
        var str = query.toString();
        if(args){
            for(let argument in args){
                var item = args[argument];
                str = str.replace("$$", item);
            }
        }
        this.__queryObject.and(str, this.__entity.__name);
        return this;
    }

    where(query,  ...args){
        var str = query.toString();
        if(args){
            for(let argument in args){
                var item = args[argument];
                str = str.replace("$$", item);
            }
        }

        this.__queryObject.where(str, this.__entity.__name);
        return this;
    }

    // when you dont want to use lazy loading and want it called at that moment
    //Eagerly loading
    include(query,  ...args){
        var str = query.toString();
        if(args){
            for(let argument in args){
                var item = args[argument];
                str = str.replace("$$", item);
            }
        }
        this.__queryObject.include(str, this.__entity.__name);
        return this;
    }

    // only takes a array of selected items
    select(query,  ...args){
        var str = query.toString();
        if(args){
            for(let argument in args){
                var item = args[argument];
                str = str.replace("$$", item);
            }
        }
        this.__queryObject.select(str, this.__entity.__name);
        return this;
    }

    take(number){
        this.__queryObject.script.take = number;
        return this;
    }

    skip(number){
        this.__queryObject.script.skip = number;
        return this;
    }

    
    // ------------------------------- FUNCTIONS THAT MAKE THE SQL CALL START FROM HERE ON -----------------------------------------------------
    // ---------------------------------------------------------------------------------------------------------------------------------------

    count(query,  ...args){
        if(query){
            var str = query.toString();
            if(args){
                for(let argument in args){
                    var item = args[argument];
                    str = str.replace("$$", item);
                }
            }
            this.__queryObject.count(str, this.__entity.__name);
        }

        if(this.__context.isSQLite){
            // trying to match string select and relace with select Count(*);
            var entityValue = this.__context._SQLEngine.getCount(this.__queryObject, this.__entity, this.__context);
            var val = entityValue[Object.keys(entityValue)[0]];
            this.__reset();
            return val;
        }
        
        if(this.__context.isMySQL){
            // trying to match string select and relace with select Count(*);
            var entityValue = this.__context._SQLEngine.getCount(this.__queryObject, this.__entity, this.__context);
            var val = entityValue[Object.keys(entityValue)[0]];
            this.__reset();
            return val;
        }
    }

    single(){
        // If no clauses were used before single(), seed defaults so SQL is valid
        if(this.__queryObject.script.entityMap.length === 0){
            this.__queryObject.skipClause(this.__entity.__name);
            this.__queryObject.script.take = 1;
        }

        if(this.__context.isSQLite){
            var entityValue = this.__context._SQLEngine.get(this.__queryObject.script, this.__entity, this.__context);
            var sing = this.__singleEntityBuilder(entityValue);
            this.__reset();
            return sing;
        }
        
        if(this.__context.isMySQL){
            var entityValue = this.__context._SQLEngine.get(this.__queryObject.script, this.__entity, this.__context);
            var sing = this.__singleEntityBuilder(entityValue[0]);
            this.__reset();
            return sing;
        }
    }

    toList(){
        if(this.__context.isSQLite){
            if(this.__queryObject.script.entityMap.length === 0){
                this.__queryObject.skipClause( this.__entity.__name);
                if(!this.__queryObject.script.take || this.__queryObject.script.take === 0){
                    this.__queryObject.script.take = 1000;
                }
            }
            var entityValue = this.__context._SQLEngine.all(this.__queryObject.script, this.__entity, this.__context);
            var toLi = this.__multipleEntityBuilder(entityValue);
            this.__reset();
            return toLi;
        }

        if(this.__context.isMySQL){
            if(this.__queryObject.script.entityMap.length === 0){
                this.__queryObject.skipClause( this.__entity.__name);
                if(!this.__queryObject.script.take || this.__queryObject.script.take === 0){
                    this.__queryObject.script.take = 1000;
                }
            }
            var entityValue = this.__context._SQLEngine.all(this.__queryObject.script, this.__entity, this.__context);
            var toLi = this.__multipleEntityBuilder(entityValue);
            this.__reset();
            return toLi;
        }
    }

      // ------------------------------- FUNCTIONS THAT UPDATE SQL START FROM HERE  -----------------------------------------------------
    // ---------------------------------------------------------------------------------------------------------------------------------------
    add(entityValue){
        entityValue.__state = "insert";
        entityValue.__entity = this.__entity;
        entityValue.__context = this.__context;
        entityValue.__name = this.__entity.__name;
        this.__context.__track(entityValue);
    }
    
    remove(entityValue){
        entityValue.__state = "delete";
        entityValue.__entity = this.__entity;
        entityValue.__context = this.__context;
    }

    removeRange(entityValues){
        for (const property in entityValues) {
            entityValues[property].__state = "delete";
            entityValues[property].__entity = this.__entity;
            entityValues[property].__context = this.__context;
        }
    }

    track(entityValue){
        entityValue.__state = "track";
        tools.clearAllProto(entityValue);
        entityValue.__entity = this.__entity;
        entityValue.__context = this.__context;
        this.__context.__track(entityValue);
    }
}

module.exports = queryMethods;


** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/QueryLanguage/queryMethods.js **
// version 0.0.5

const LOG_OPERATORS_REGEX = /(\|\|)|(&&)/;
var tools =  require('../Tools');

class queryScript{

    constructor(){ }

    script = {
        select : false,
        where: false,
        and : [],
        include : [],
        raw: false,
        entity : "",
        entityMap : [],
        take : 0,
        skip: 0,
        orderBy : false,
        orderByDesc : false,
        parentName : ""
    };


    reset(){
        this.script = {
            select : false,
            where: false,
            and : [],
            include : [],
            raw: false,
            entity : "",
            entityMap : [],
            take : 0,
            skip: 0,
            orderBy : false,
            orderByDesc : false
        };
    }

    getScript(){
        return this.script;
    }

    raw(query){
        this.script.raw = query;
        return this.script;
    }

    orderBy(text, entityName){
        this.buildScript(text, "orderBy", this.script, entityName);
        return this.script;
    }

    orderByDesc(text, entityName){
        this.buildScript(text, "orderByDesc", this.script, entityName);
        return this.script;
    }

    and(text, entityName){
        this.buildScript(text, "and", this.script, entityName);
        return this.script;
    }

    where(text, entityName){
        this.buildScript(text, "where", this.script, entityName);
        return this.script;
    }

    // this gets called when you skip a where clause
    skipClause(entityName){
        //this.buildScript(text, "skipClause", this.script, entityName);
        this.script.entityMap.push({
            name: entityName,
            entity : "ran"
        });
        this.script.parentName = entityName;
        return this.script;
    }

    include(text, entityName){
        this.buildScript(text, "include", this.script, entityName);
        return this.script;
    }

    select(text, entityName){
        this.buildScript(text, "select", this.script, entityName);
        return this.script;
    }

    count(text, entityName){
        this.buildScript(text, "count", this.script, entityName);
        return this.script;
    }

    buildScript(text, type, obj, entityName){

        var cachedExpr = {}; // this function will just get the high level

        /// first we find all the groups in the query string
        var querySections = this.getFunctionsInQuery(text);

        // remove spaces from query and get the Entity
        cachedExpr.entity = this.getEntity(text);
        

        if(!this.isMapped(entityName, obj.entityMap)){

            obj.entityMap.push({
                name: entityName,
                entity : cachedExpr.entity
            });
        }

        // attach the entity name to the main Object
        obj.entity = cachedExpr.entity

        cachedExpr[entityName] = this.splitGroupsByLogicalOperators(querySections.query);
        
        // lets break the string into a list of functions
        this.buildFields(text, cachedExpr);

        if(type === "include"){
            if(cachedExpr.selectFields){
                if(!this.isMapped(cachedExpr.selectFields[0], obj.entityMap)){
                    obj.entityMap.push({
                        name: tools.capitalizeFirstLetter(cachedExpr.selectFields[0]),
                        entity : tools.getRandomLetter(1, obj.entityMap)
                    });
                }
            };
        }

        this.describeExpressionParts(cachedExpr[entityName]);
        this.describeExpressionPartsFunctions(cachedExpr[entityName], querySections.functions);
        if(type === "include" || type === "and"){
            obj[type].push(cachedExpr);
        }
        else{
            obj[type] = cachedExpr;
        }

        obj.parentName = entityName;
        return cachedExpr;
    }

   

    // look and grab all fields
    buildFields(text, desc){
        var match = text.match(/^([\w\d$_]+?)\s*=>((?:\{\sreturn\s)?[\s\S]*(?:\})?)/);
        if(match){
            const entity = match[1];
            let exprStr = match[2];
            const fields = [];

            exprStr.replace(new RegExp(entity + "\\.([\\w_]+)", "g"), function (_, field) {
                if (!fields.includes(field)) fields.push(field);
            });

            desc.expr = exprStr.trim();
            desc.selectFields = fields;
            return desc;
        }
        else{
            return null;

        }
    }

    MATCH_ENTITY_REGEXP(entityName) {
      return new RegExp("(^|[^\\w\\d])" + entityName + "[ \\.\\)]");
    }

    OPERATORS_REGEX(entityName){
        return  new RegExp("(?:^|[^\\w\\d])" + entityName
        + "\\.((?:\\.?[\\w\\d_\\$]+)+)(?:\\((.*?)\\))?(?:\\s*(>|<|(?:===)|(?:!==)|(?:==)|(?:!=)|(?:=)|(?:<=)|(?:>=)|(?:in))\\s*(.*))?")
    }


    splitGroupsByLogicalOperators(text) {
        let parts = {}, tmp;
        var part = {query : text, name : "query"}

        //tmp = this.splitByLogicalOperators(part.query, entityRegExp)
        tmp = this.extractInside(part.query, part.name);
        if(tmp){
            part.inside = tmp;
            parts[part.name] = part;
        }
        else{
            part.inside = part.query;
            parts[part.name] = part;
        }
        part.inside = part.inside.replaceAll("&&", "and");
        part.query = part.query.replaceAll("&&", "and");
        part.inside = part.inside.replaceAll("||", "or");
        part.query = part.query.replaceAll("||", "or");

        return parts;
    }


    // find all functions from querySections
    getFunctionsInQuery(text) {

        const regex = /(?<=\.(?=[A-z]+\())([^(]+)\((.+?)\)(?!\))/g;
        let m;
        const items = [];
        
        while ((m = regex.exec(text)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            
            const [, fName, query] = m;
            items.push(
                {name: fName, query: query, inside : query, parentFeild : this.getParentField(text, m[0]), input: m.input}
            );

           text = text.replace(`${fName}(${query})`, `func`);

        }

        //items.push({name: "NOFUNCTIONS", query: str})
        
        return {
            functions: items,
            query : text
        };
    }

    getParentField(text, funcName){
       var split = text.split(".");
       for (let i = 0; i < split.length; i++) {

            if(split[i].includes(funcName)){
                return split[i -1];
            }
        }
        return "";
    }

    findExpression(fieldName, expression){
        // loop through and find expression
        for (const key in expression) {

           if(expression[key].field === fieldName){
            return expression[key]
           }
        }
    }

    describeExpressionPartsFunctions(cachedExpr, functions){
        cachedExpr.functions = [];
        if(functions.length > 0){
            for (let item in functions) {

                var part = functions[item];
                var partQuery = part.inside;
                // get entity of inside function
                var entity =  this.getEntity(partQuery);
                
                part.entity = entity;

                // is the function name white listed
                if(this.isFunction(part.name)){
                    var scriptInner =  {
                        select : false,
                        where: false,
                        and : [],
                        include : [],
                        raw: false,
                        entity : "",
                        entityMap : [],
                        take : 0,
                        skip: 0,
                        orderBy : false,
                        orderByDesc : false
                    };
                    
                    if(part.name === "where"){
                        // TODO: we need to Get this working 
                        // recall to parse inner query of function that is being called 
                        this.buildScript(part.inside, part.name, scriptInner, part.parentFeild);
                        part.parentName = scriptInner.parentName;
                        part.entity = scriptInner.where.entity;
                        part.expr = scriptInner.where.expr;
                        part.selectFields = scriptInner.where.selectFields;
                        part[scriptInner.parentName] = scriptInner.where[scriptInner.parentName];
                    }
                    if(part.name === "include"){
                        // TODO: we need to Get this working 
                        // recall to parse inner query of function that is being called 
                        this.buildScript(part.inside, part.name, scriptInner, part.parentFeild);
                        part.parentName = scriptInner.parentName;
                        part.entity = scriptInner.include.entity;
                        part.expr = scriptInner.include.expr;
                        part.selectFields = scriptInner.include.selectFields;
                        part[scriptInner.parentName] = scriptInner.include[scriptInner.parentName];
    
                    }
                    if(part.name === "select"){
                        // TODO: we need to Get this working 
                        // recall to parse inner query of function that is being called 
                        this.buildScript(part.inside, part.name, scriptInner, part.parentFeild);
                        part.parentName = scriptInner.parentName;
                        part.entity = scriptInner.select.entity;
                        part.expr = scriptInner.select.expr;
                        part.selectFields = scriptInner.select.selectFields;
                        part[scriptInner.parentName] = scriptInner.select[scriptInner.parentName];
                    }

                    // will search multiple values in a field
                    if(part.name === "any"){
                        // var members = data.memberContext.Member.where(r => r.first_name.any($$), "Rich, james, Oliver" ).toList();
                        var expre = this.findExpression(part.parentFeild, cachedExpr.query.expressions)
                        expre.func = "IN";
                        expre.arg = `(${part.query})`;
                        expre.isFunction = true;
                    }

                    if(part.name === "like"){
                        // var members = data.memberContext.Member.where(r => r.space_id == $$ && r.user_id != null && r.first_name.like($$),data.params.query.id, "r" ).toList();
                        var expre = this.findExpression(part.parentFeild, cachedExpr.query.expressions)
                        expre.func = part.name;
                        expre.arg = part.query;
                        expre.isFunction = true;
                    }

                }
                else{
                throw "Cannot have inner functions unless its a Where, Include, Select or Like caluse"
                }  
            }
        }
        
    }

    describeExpressionParts(parts) {
        if(parts.query) {
            let  match, fields, func, arg;
            var part = {};
            part.inside = parts.query.query;
            part.expressions = [];
            var partQuery = part.inside;
            var entity =  this.getEntity(partQuery);
            var exprPartRegExp = this.OPERATORS_REGEX(entity);
            // check if query contains an AND.
            var trimmedQuery = partQuery.replace(/\s/g, '');
           var splitByAnd = trimmedQuery.split("and");
           for (let splitAnds in splitByAnd) {

                if (match = splitByAnd[splitAnds].match(exprPartRegExp)) {
                    fields = match[1].split(".");
                    func = (match[2] ? fields[fields.length - 1] : (match[3] || "exists"));
                    
                    if (func == "==" || func == "===") {
                        func = "=";
                    }
                    else if (func == "!==") {
                        func = "!=";
                    }

                    arg = match[2] || match[4];
                    if (arg == "true" || arg == "false") {
                        arg = arg == "true";
                    }
                    else if (arg && arg.charAt(0) == arg.charAt(arg.length - 1) && (arg.charAt(0) == "'" || arg.charAt(0) == '"')) {
                        arg = arg.slice(1, -1);
                    }

                    part.entity = entity;
                
                    part.expressions.push({
                        field: fields[0],
                        func : func.toLowerCase(),
                        arg : arg
                    });
                    parts.query =  part;
                }
           }
        }

        return parts;
    }

    getEntity(str){
        var clean = str.replace(/\s/g, '');  
        return clean.substring(0, 1);
    }

    isMapped(name, maps){
        for (let item in maps) {
            var map = maps[item];
            if(tools.capitalizeFirstLetter(name) === map.name){
                return true
            }
        }
        return false;
    }

    //const res1 = extractInside(`User.include(a => a.Profile.where(r => r.name.startWith(i))).single()`, 'where');
    // const res2 = extractInside(`User.include(a => a.Profile.select(r => r.name === "rick")).single()`, 'select');
    extractInside(str, fname) {
        if(this.isFunction(fname)){
            const startIndex = str.indexOf(fname) + fname.length;
            const stack = [];
            for (let i = startIndex; i < str.length; i++) {
                if(str[i] === '(') {
                    stack.push(str[i]);

                } else if (str[i] === ')') {
                    stack.pop();
                }
                if(stack.length === 0) {
                    return str.substring(startIndex+1, i);
                }
            }
            return str;
        }
        else{
            return null;
        }
    }
    
    isFunction(func){
        var funcList = [ "include", "like", "any"]
        for(var i =0; i < funcList.length; i++){
            if(funcList[i] === func){
                return true
            }
        }
        return false;
    }

}

module.exports = queryScript;
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/QueryLanguage/queryScrip// Version 0.0.19
var tools =  require('masterrecord/Tools');

class SQLLiteEngine {

    unsupportedWords = ["order"]

    update(query){
        var sqlQuery = ` UPDATE [${query.tableName}]
        SET ${query.arg}
        WHERE [${query.tableName}].[${query.primaryKey}] = ${query.primaryKeyValue}` // primary key for that table = 
        return this._run(sqlQuery);
    }

    delete(queryObject){
       var sqlObject = this._buildDeleteObject(queryObject);
       var sqlQuery = `DELETE FROM [${sqlObject.tableName}] WHERE [${sqlObject.tableName}].[${sqlObject.primaryKey}] = ${sqlObject.value}`;
       return this._execute(sqlQuery);
    }

    insert(queryObject){
        var sqlObject = this._buildSQLInsertObject(queryObject, queryObject.__entity);
        var query = `INSERT INTO [${sqlObject.tableName}] (${sqlObject.columns})
        VALUES (${sqlObject.values})`;
        var queryObj = this._run(query);
        var open = {
            "id": queryObj.lastInsertRowid
        };
        return open;
    }

    get(query, entity, context){
        var queryString = {};
        try {
            if(query.raw){
                queryString.query = query.raw;
            }
            else{
                if(typeof query === 'string'){
                    queryString.query = query;
                }
                else{
                    queryString = this.buildQuery(query, entity, context);
                }
            }
            if(queryString.query){
                console.log("SQL:", queryString.query);
                var queryReturn = this.db.prepare(queryString.query).get();
                return queryReturn;
            }
            return null;
        } catch (err) {
            console.error(err);
            return null;
        }
    }

    getCount(queryObject, entity, context){
        var query = queryObject.script;
        var queryString = {};
        try {
            if(query.raw){
                queryString.query = query.raw;
            }
            else{
                if(query.count === undefined){
                    query.count = "none";
                }
                queryString.entity = this.getEntity(entity.__name, query.entityMap);
                queryString.query = `SELECT ${this.buildCount(query, entity)} ${this.buildFrom(query, entity)} ${this.buildWhere(query, entity)}`
            }
            if(queryString.query){
                var queryCount = queryString.query
                console.log("SQL:", queryCount );
                var queryReturn = this.db.prepare(queryCount ).get();
                return queryReturn;
            }
            return null;
        } catch (err) {
            console.error(err);
            return null;
        }
    }

    all(query, entity, context){
        var selectQuery = {};
        try {
            if(query.raw){
                selectQuery.query = query.raw;
            }
            else{
              
                selectQuery = this.buildQuery(query, entity, context);
            }
            if(selectQuery.query){
                console.log("SQL:", selectQuery.query);
                var queryReturn = this.db.prepare(selectQuery.query).all();
                return queryReturn;
            }
            return null;
        } catch (err) {
            console.error(err);
            return null;
        }
    }

    changeNullQuery(query){
        if(query.where){
            var whereClaus;
            whereClaus = query.where.expr.replace("=== null", "is null");
            if(whereClaus === query.where.expr){
                whereClaus = query.where.expr.replace("!= null", "is not null");
            }
            query.where.expr = whereClaus;
        }

    }

    buildCount(query, mainQuery){
            var entity = this.getEntity(query.parentName, query.entityMap);
            if(query.count){
                if(query.count !== "none"){
                    return `COUNT(${entity}.${query.count.selectFields[0]})`
                }
                else{
                    return `COUNT(*)`
                }             
            }
            else{
                return ""
            }
    }

    buildQuery(query, entity, context, limit){

        var queryObject = {};
        queryObject.entity = this.getEntity(entity.__name, query.entityMap);
        queryObject.select = this.buildSelect(query, entity);
        queryObject.count = this.buildCount(query, entity);
        queryObject.from = this.buildFrom(query, entity);
        queryObject.include = this.buildInclude(query, entity, context, queryObject);
        queryObject.where = this.buildWhere(query, entity);
        queryObject.and = this.buildAnd(query, entity);
        queryObject.take = this.buildTake(query);
        queryObject.skip = this.buildSkip(query);
        queryObject.orderBy = this.buildOrderBy(query);


        var queryString = `${queryObject.select} ${queryObject.count} ${queryObject.from} ${queryObject.include} ${queryObject.where} ${queryObject.and} ${queryObject.orderBy} ${queryObject.take} ${queryObject.skip}`;
        return { 
                query : queryString,
                entity : this.getEntity(entity.__name, query.entityMap)
        }

    }

    buildOrderBy(query){
        // ORDER BY column1, column2, ... ASC|DESC;
        var $that = this;
        var orderByType = "ASC";
        var orderByEntity = query.orderBy;
        var strQuery = "";
        if(orderByEntity === false){
            orderByType = "DESC";
            orderByEntity = query.orderByDesc;
        }
        if(orderByEntity){
            var entity = this.getEntity(query.parentName, query.entityMap);
            var fieldList = "";
            for (const item in orderByEntity.selectFields) {
                fieldList += `${entity}.${orderByEntity.selectFields[item]}, `;
            };
            fieldList = fieldList.replace(/,\s*$/, "");
            strQuery = "ORDER BY";
            strQuery += ` ${fieldList} ${orderByType}`;
        }
        return strQuery;
    }

    buildTake(query){
        if(query.take){
            return `LIMIT ${query.take}`
        }
        else{
            return "";
        }
    }

    buildSkip(query){
        if(query.skip){
            return `OFFSET ${query.skip}`
        }
        else{
            return "";
        }
    }

    buildAnd(query, mainQuery){
        // loop through the AND
        // loop update ther where .expr
        var andEntity = query.and;
        var strQuery = "";
        var $that = this;
        var str = "";

        if(andEntity){
            var entity = this.getEntity(query.parentName, query.entityMap);
            var andList = [];
            for (let entityPart in andEntity) { // loop through list of and's
                    var itemEntity = andEntity[entityPart]; // get the entityANd
                for (let table in itemEntity[query.parentName]) { // find the main table
                     var item = itemEntity[query.parentName][table];
                    for (let exp in item.expressions) {
                        var field = tools.capitalizeFirstLetter(item.expressions[exp].field);
                        if(mainQuery[field]){
                            if(mainQuery[field].isNavigational){
                                entity = $that.getEntity(field, query.entityMap);
                                field = item.fields[1];
                            }
                        }
                        if(item.expressions[exp].arg === "null"){
                            if(item.expressions[exp].func === "="){
                                item.expressions[exp].func = "is"
                            }
                            if(item.expressions[exp].func === "!="){
                                item.expressions[exp].func = "is not"
                            }
                        }
                        if(strQuery === ""){
                            if(item.expressions[exp].arg === "null"){
                                strQuery = `${entity}.${field}  ${item.expressions[exp].func} ${item.expressions[exp].arg}`;
                            }else{
                                strQuery = `${entity}.${field}  ${item.expressions[exp].func} '${item.expressions[exp].arg}'`;
                            }
                        }
                        else{
                            if(item.expressions[exp].arg === "null"){
                                strQuery = `${strQuery} and ${entity}.${field}  ${item.expressions[exp].func} ${item.expressions[exp].arg}`;
                            }else{
                                strQuery = `${strQuery} and ${entity}.${field}  ${item.expressions[exp].func} '${item.expressions[exp].arg}'`;
                            }
                           
                        }
                    }
                    andList.push(strQuery);
                }
            }
        }
        
        if(andList.length > 0){
            str = `and ${andList.join(" and ")}`;
        }
        return str
    }

    buildWhere(query, mainQuery){
        var whereEntity = query.where;

        var strQuery = "";
        var $that = this;
        if(whereEntity){
            var entity = this.getEntity(query.parentName, query.entityMap);

            var item = whereEntity[query.parentName].query;
            for (let exp in item.expressions) {
                var field = item.expressions[exp].field.toLowerCase();
                // var field = tools.capitalizeFirstLetter(item.expressions[exp].field); removed this because it was causing issues not sure why we added it in the firstplace
                if(mainQuery[field]){
                    if(mainQuery[field].isNavigational){
                        entity = $that.getEntity(field, query.entityMap);
                        field = item.fields[1];
                    }
                }
                if(item.expressions[exp].arg === "null"){
                    if(item.expressions[exp].func === "="){
                        item.expressions[exp].func = "is"
                    }
                    if(item.expressions[exp].func === "!="){
                        item.expressions[exp].func = "is not"
                    }
                }
                if(strQuery === ""){
                    if(item.expressions[exp].arg === "null"){
                        strQuery = `WHERE ${entity}.${field}  ${item.expressions[exp].func} ${item.expressions[exp].arg}`;
                    }else{
                        if(item.expressions[exp].func === "IN"){
                            strQuery = `WHERE ${entity}.${field}  ${item.expressions[exp].func} ${item.expressions[exp].arg}`;
                        }
                        else{
                            strQuery = `WHERE ${entity}.${field}  ${item.expressions[exp].func} '${item.expressions[exp].arg}'`;
                        }
                    }
                }
                else{
                    if(item.expressions[exp].arg === "null"){
                        strQuery = `${strQuery} and ${entity}.${field}  ${item.expressions[exp].func} ${item.expressions[exp].arg}`;
                    }else{
                        strQuery = `${strQuery} and ${entity}.${field}  ${item.expressions[exp].func} '${item.expressions[exp].arg}'`;
                    }
                    
                }
            }

            
                
        }
        return strQuery;
    }

    buildInclude( query, entity, context){
        var includeQuery =  "";
        for (let part in query.include) {
            var includeEntity = query.include[part];
            var $that = this;
            if(includeEntity){
                var parentObj = includeEntity[query.parentName];
                var currentContext = "";
                if(includeEntity.selectFields){
                    currentContext = context[tools.capitalizeFirstLetter(includeEntity.selectFields[0])];
                }
                
                if(parentObj){
                    parentObj.entityMap = query.entityMap;
                    var foreignKey = $that.getForeignKey(entity.__name, currentContext.__entity);
                    var mainPrimaryKey = $that.getPrimarykey(entity);
                    var mainEntity = $that.getEntity(entity.__name, query.entityMap);
                    if(currentContext.__entity[entity.__name].type === "hasManyThrough"){
                        var foreignTable = tools.capitalizeFirstLetter(currentContext.__entity[entity.__name].foreignTable); //to uppercase letter
                        foreignKey = $that.getPrimarykey(currentContext.__entity);
                        mainPrimaryKey = context[foreignTable].__entity[currentContext.__entity.__name].foreignKey;
                        var mainEntity = $that.getEntity(foreignTable,query.entityMap);
                    }
                    // add foreign key to select so that it picks it up
                    if(parentObj.select){
                        parentObj.select.selectFields.push(foreignKey);
                    }else{
                        parentObj.select = {};
                        parentObj.select.selectFields = [];
                        parentObj.select.selectFields.push(foreignKey);
                    }

                    var innerQuery = $that.buildQuery(parentObj, currentContext.__entity, context);

                    includeQuery += `LEFT JOIN (${innerQuery.query}) AS ${innerQuery.entity} ON ${ mainEntity}.${mainPrimaryKey} = ${innerQuery.entity}.${foreignKey} `;

                }
            }
        }
        return includeQuery;
    }

    buildFrom(query, entity){
        var entityName = this.getEntity(entity.__name, query.entityMap);
        if(entityName ){
            return `FROM ${entity.__name } AS ${entityName}`;
        }
        else{ return "" }
    }

    buildSelect(query, entity){
        // this means that there is a select statement
        var select = "SELECT";
        var arr = "";
        var $that = this;
        if(query.select){
            for (const item in query.select.selectFields) {
                arr += `${$that.getEntity(entity.__name, query.entityMap)}.${query.select.selectFields[item]}, `;
            };
          
        }
        else{
            var entityList = this.getEntityList(entity);
            for (const item in entityList) {
                arr += `${$that.getEntity(entity.__name, query.entityMap)}.${entityList[item]}, `;
            };
        }
        arr = arr.replace(/,\s*$/, "");
        return `${select} ${arr} `;
    }

    getForeignKey(name, entity){
        if(entity && name){
           return entity[name].foreignKey;
        }
    }

    getPrimarykey(entity){
            for (const item in entity) {
                if(entity[item].primary){
                    if(entity[item].primary === true){
                        return entity[item].name;
                    }
                }
            };
    }

    getForeignTable(name, entity){
        if(entity && name){
           return entity[name].foreignTable;
        }
    }

    getInclude(name, query){
        var include = query.include;
        if(include){
            for (let part in include) {
                if(tools.capitalizeFirstLetter(include[part].selectFields[0]) === name){
                    return include[part];
                }
            }
        }
        else{
            return "";
        }
    }

    getEntity(name, maps){
        for (let item in maps) {
            var map = maps[item];
            if(tools.capitalizeFirstLetter(name) === tools.capitalizeFirstLetter(map.name)){
                return map.entity
            }
        }
        return "";
    }

 // return a list of entity names and skip foreign keys and underscore.
 getEntityList(entity){
    var entitiesList = [];
    var $that = this;
    for (var ent in entity) {
            if(!ent.startsWith("_")){
                if(!entity[ent].foreignKey){
                    if(entity[ent].relationshipTable){
                        if($that.chechUnsupportedWords(entity[ent].relationshipTable)){
                            entitiesList.push(`'${entity[ent].relationshipTable}'`);
                        }
                        else{
                            entitiesList.push(entity[ent].relationshipTable);
                        }
                    }
                    else{
                        if($that.chechUnsupportedWords(ent)){
                            entitiesList.push(`'${ent}'`);
                        }
                        else{
                            entitiesList.push(ent);
                        }
                    }
                }
                else{
                    
                    if(entity[ent].relationshipType === "belongsTo"){
                        var name = entity[ent].foreignKey;
                        if($that.chechUnsupportedWords(name)){
                            entitiesList.push(`'${name}'`);
                            //entitiesList.push(`'${ent}'`);
                        }
                        else{
                            entitiesList.push(name);
                            //entitiesList.push(ent);
                        }
                    }
                    
                }
            }
        }
    return entitiesList
}
    chechUnsupportedWords(word){
        for (var item in this.unsupportedWords) {
            var text = this.unsupportedWords[item];
            if(text === word){
                return true
            }
        }
        return false;
    }

    startTransaction(){
        this.db.prepare('BEGIN').run();
    }

    endTransaction(){
        this.db.prepare('COMMIT').run();
    }

    errorTransaction(){
        this.db.prepare('ROLLBACK').run();
    }

    _buildSQLEqualTo(model){
        var $that = this;
        var argument = null;
        var dirtyFields = model.__dirtyFields;

        for (var column in dirtyFields) {

            var type = model.__entity[dirtyFields[column]].type;

            if(model.__entity[dirtyFields[column]].relationshipType === "belongsTo"){
                type = "belongsTo";
            }
            // TODO Boolean value is a string with a letter
            switch(type){
                case "belongsTo" :
                    const foreignKey = model.__entity[dirtyFields[column]].foreignKey;
                    argument = `${foreignKey} = ${model[dirtyFields[column]]},`;
                break;
                 case "integer" :
                     //model.__entity[dirtyFields[column]].skipGetFunction = true;
                    var columneValue = model[`_${dirtyFields[column]}`];
                    argument = argument === null ? `[${dirtyFields[column]}] = ${model[dirtyFields[column]]},` : `${argument} [${dirtyFields[column]}] = ${columneValue},`;
                    //model.__entity[dirtyFields[column]].skipGetFunction = false;
                break;
                case "string" :
                    argument = argument === null ? `[${dirtyFields[column]}] = '${$that._santizeSingleQuotes(model[dirtyFields[column]])}',` : `${argument} [${dirtyFields[column]}] = '${$that._santizeSingleQuotes(model[dirtyFields[column]])}',`;
                break;
                case "boolean" :
                    var bool = "";
                    if(model.__entity[dirtyFields[column]].valueConversion){
                        bool = tools.convertBooleanToNumber(model[dirtyFields[column]]);
                    }
                    else{
                        bool = model[dirtyFields[column]];
                    }
                    argument = argument === null ? `[${dirtyFields[column]}] = '${bool}',` : `${argument} [${dirtyFields[column]}] = ${bool},`;
                break;
                case "time" :
                    argument = argument === null ? `[${dirtyFields[column]}] = '${model[dirtyFields[column]]}',` : `${argument} [${dirtyFields[column]}] = ${model[dirtyFields[column]]},`;
                break;
                case "belongsTo" :
                    var fore = `_${dirtyFields[column]}`;
                    argument = argument === null ? `[${model.__entity[dirtyFields[column]].foreignKey}] = '${model[fore]}',` : `${argument} [${model.__entity[dirtyFields[column]].foreignKey}] = '${model[fore]}',`;
                break;
                case "hasMany" :
                    argument = argument === null ? `[${dirtyFields[column]}] = '${model[dirtyFields[column]]}',` : `${argument} [${dirtyFields[column]}] = '${model[dirtyFields[column]]}',`;
                break;
                default:
                    argument = argument === null ? `[${dirtyFields[column]}] = '${model[dirtyFields[column]]}',` : `${argument} [${dirtyFields[column]}] = '${model[dirtyFields[column]]}',`;
            }
        }

        if(argument){
            return argument.replace(/,\s*$/, "");
        }
        else{
            return -1;
        }
       
    }

    
    _buildDeleteObject(currentModel){
        var primaryKey = currentModel.__Key === undefined ? tools.getPrimaryKeyObject(currentModel.__entity) : currentModel.__Key;
        var value = currentModel.__value === undefined ? currentModel[primaryKey] : currentModel.__value;
        var tableName = currentModel.__tableName === undefined ? currentModel.__entity.__name : currentModel.__tableName;
        return {tableName: tableName, primaryKey : primaryKey, value : value};
    }


       // return columns and value strings
    _buildSQLInsertObject(fields, modelEntity){
        var $that = this;
        var columns = null;
        var values = null;
        for (var column in modelEntity) {
            // column1 = value1, column2 = value2, ...
            if(column.indexOf("__") === -1 ){
                // call the get method if avlable
                var fieldColumn = "";
                // check if get function is avaliable if so use that
                fieldColumn = fields[column];

                if((fieldColumn !== undefined && fieldColumn !== null ) && typeof(fieldColumn) !== "object"){
                    switch(modelEntity[column].type){
                        case "string" : 
                            fieldColumn = `'${$that._santizeSingleQuotes(fields[column])}'`;
                        break;
                        case "time" : 
                            fieldColumn = fields[column];
                        break;
                    }

                    var relationship = modelEntity[column].relationshipType
                    if(relationship === "belongsTo"){
                        column = modelEntity[column].foreignKey
                    }

                    columns = columns === null ? `'${column}',` : `${columns} '${column}',`;
                    values = values === null ? `${fieldColumn},` : `${values} ${fieldColumn},`;

                }
                else{
                    switch(modelEntity[column].type){
                        case "belongsTo" :
                            var fieldObject = tools.findTrackedObject(fields.__context.__trackedEntities, column );
                            if( Object.keys(fieldObject).length > 0){
                                var primaryKey = tools.getPrimaryKeyObject(fieldObject.__entity);
                                fieldColumn = fieldObject[primaryKey];
                                column = modelEntity[column].foreignKey;
                                columns = columns === null ? `'${column}',` : `${columns} '${column}',`;
                                values = values === null ? `${fieldColumn},` : `${values} ${fieldColumn},`;
                            }else{
                                console.log("Cannot find belings to relationship")
                            }
    
                        break;
                    }
                
                }
            }
        }
        return {tableName: modelEntity.__name, columns: columns.replace(/,\s*$/, ""), values: values.replace(/,\s*$/, "")};

    }

    // will add double single quotes to allow sting to be saved.
    _santizeSingleQuotes(string){
        if (typeof string === 'string' || string instanceof String){
            return string.replace(/'/g, "''");
        }
    else{
        console.log("warning - Field being passed is not a string");
        throw "error warning - Field being passed is not a string";
    }
    }

    // converts any object into SQL parameter select string
    _convertEntityToSelectParameterString(obj, entityName){
        // todo: loop throgh object and append string with comma to 
        var mainString = "";
        const entries = Object.keys(obj);

        for (const [name] of entries) {
         mainString += `${mainString}, ${entityName}.${name}`;
        }
        return mainString;;
    }

    _execute(query){
        console.log("SQL:", query);
        return this.db.exec(query);
    }

    _run(query){
        console.log("SQL:", query);
        return this.db.prepare(query).run();
    }

    setDB(db, type){
       this.db = db;
       this.dbType = type; // this will let us know which type of sqlengine to use.
   }
}

module.exports = SQLLiteEngine;
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/SQLLiteEngine.js **
// Version 0.0.4
class Tools{

    static checkIfArrayLike(obj) {
        if (Array.isArray(obj)) {
          return true;
        }
      
        if (
          obj &&
          typeof obj === 'object' &&
          Object.keys(obj).some(k => !isNaN(k)) &&
          '0' in obj
        ) {
          return true;
        }
      
        return -1;
    }

    static returnEntityList(list, entityList ){
        var newList = [];
        for(var max = 0; max < list.length; max++ ){
            var ent = entityList[list[max]];
            if(ent){
                if(ent.relationshipType === "hasMany" || ent.relationshipType === "hasOne"){
                    newList.push(ent.name);
                } 
            }
        }
        return newList;
    }

    static findEntity(name, entityList){
        return entityList[name];
    }

    // this will remove everthing from back slash amount
    static removeBackwardSlashSection(string, amount, type){
        type = type === undefined ? "\\" : type;
        var stringArray =  string.split(type);
        for(var i = 0; i < amount; i++){
            stringArray.pop();
        }
        return stringArray.join(type);
    }

    static getPrimaryKeyObject(model){
        for (var key in model) {
            if (model.hasOwnProperty(key)) {
                if(model[key].primary){
                    if(model[key].primary === true){
                        return key
                    }
                }
            }
        }
    }

    static findForeignTable(name, model){
        for (var key in model) {
            if (model.hasOwnProperty(key)) {
                if(model[key].foreignTable){
                    if(model[key].foreignTable === name){
                        return model[key];
                    }
                }
            }
        }
        return null;
    }

    static createNewInstance(validModel, type, classModel){
        return new type(validModel, classModel);
    }

    static findTrackedObject(obj, name){
        for (const property in obj) {
            if(obj[property].__name === name){
                return obj[property];
            }
        }
        return {};
    }

    static clearAllProto(proto){
       
        var newproto = {}
        if(proto.__proto__ ){
            for (var key in proto) {
                if(!key.startsWith("_")){
                    var typeObj = typeof(proto[key]);
                    newproto[key] = proto[key];
                    if(typeObj === "object"){
                        proto[key] = this.clearAllProto(proto[key]);
                    }
                }
            }
        }

         newproto["__name"] = proto["__name"];
         newproto["__state"] = proto["__state"];
         newproto["__entity"] = proto["__entity"];
         newproto["__context"] = proto["__context"];
         newproto["__dirtyFields"] = proto["__dirtyFields"];
         
         newproto.__proto__ = null;
        return newproto;

    }

    static removePrimarykeyandVirtual(currentModel, modelEntity){
        var newCurrentModel = Object.create(currentModel);

        for(var entity in modelEntity) {
            var currentEntity = modelEntity[entity];
            if (modelEntity.hasOwnProperty(entity)) {
                if(currentEntity.primary === true){
                    delete newCurrentModel[`_${entity}`];
                }
            }
            if(currentEntity.virtual === true){
                // skip it from the insert
                delete newCurrentModel[`_${entity}`];
            }

        }
        return newCurrentModel;
    }

    static getEntity(name, modelEntity){
        for(var entity in modelEntity) {
            var currentEntity = modelEntity[entity];
            if (modelEntity.hasOwnProperty(entity)) {
                if(currentEntity.__name === name){
                    return currentEntity;
                }
            }
        }
        return false;
    }

    static capitalize = (s) => {
        if (typeof s !== 'string') return ''
        return s.charAt(0).toUpperCase() + s.slice(1)
    }

    static capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }

             // return randome letter that is not the skip letter
    static getRandomLetter(length, skip){
        var result           = '';
        var characters       = 'abcdefghijklmnopqrstuvwxyz';
        var charactersLength = characters.length;
        
        for ( var i = 0; i < length; i++ ) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
            if(skip){
                for ( var b = 0; b < skip.length; b++ ) {
                    if(result === skip[i].entity){
                        result = "";
                        i--;
                    }
                }
            }
        }
         
       return result;
    }

    // TODO: this should be removed once we create a SQLIte Manager;
    // converts any object into SQL parameter select string

    static convertEntityToSelectParameterString(obj){
        // todo: loop throgh object and append string with comma to 
        var mainString = "";
        const entries = Object.keys(obj);
        for (const key of entries) {
            if(obj[key].type !== 'hasManyThrough' && obj[key].type !== "hasMany" && obj[key].type !== "hasOne"){
                if(obj[key].name){
                    mainString = mainString === "" ?  `${obj.__name}.${obj[key].name}` : `${mainString}, ${obj.__name}.${obj[key].name}`;
                }
            }
          }
        return mainString;;
    }

    static convertBooleanToNumber(num) {
        num = num === 'true' ? true : (num === 'false' ? false : num);
        return num ? 1 : 0;
   }
}

module.exports = Tools;
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/Tools.js **
// Version 0.0.13

var modelBuilder  = require('./Entity/entityModelBuilder');
var query = require('masterrecord/QueryLanguage/queryMethods');
var tools =  require('./Tools');
var SQLLiteEngine = require('masterrecord/SQLLiteEngine');
var MYSQLEngine = require('masterrecord/mySQLEngine');
var insertManager = require('./insertManager');
var deleteManager = require('./deleteManager');
var globSearch = require("glob");
var fs = require('fs');
const appRoot = require('app-root-path');
const MySQLClient = require('masterrecord/mySQLSyncConnect');

class context {
    _isModelValid = {
        isValid: true,
        errors: []
    };
    __entities = [];
    __builderEntities = [];
    __trackedEntities = [];
    __relationshipModels = [];
    __environment = "";
    __name = "";
    isSQLite = false;
    isMySQL = false;
    isPostgres = false;

    constructor(){
        this. __environment = process.env.master;
        this.__name = this.constructor.name;
        this._SQLEngine = "";
    }

        /* 
        SQLite expected model 
        {
            "type": "better-sqlite3",
            "connection" : "/db/",
            "password": "",
            "username": ""
        }
    */
    __SQLiteInit(env, sqlName){
        try{
           
            const sqlite3 = require(sqlName);
            let DBAddress = env.completeConnection;
            var db = new sqlite3(DBAddress, env);
            db.__name = sqlName;
            this._SQLEngine = new SQLLiteEngine();
            return db;
        }
        catch (e) {
            console.log("error SQL", e);
            throw error(e)
        }
    }

    /*
    mysql expected model
         {
             "type": "mysql",
            host     : 'localhost',
            user     : 'me',
            password : 'secret',
            database : 'my_db'
          }
          */
    __mysqlInit(env, sqlName){
        try{
 
            //const mysql = require(sqlName);
            const connection = new MySQLClient(env);
            this._SQLEngine = new MYSQLEngine();
            this._SQLEngine.__name = sqlName;
            return connection;

        }
        catch (e) {
            console.log("error SQL", e);
        }
    }

    __clearErrorHandler(){
        this._isModelValid = {
            isValid: true,
            errors: []
        };
    };

    __findSettings(root, rootFolderLocation, envType){

        if(envType === undefined){
            envType = "development";
        }
        var rootFolder = `${root}/${rootFolderLocation}`;
        var search = `${rootFolder}/**/*env.${envType}.json`;
        var files = globSearch.sync(search, rootFolder);
        var file = files[0];
        if(file === undefined){
            root = tools.removeBackwardSlashSection(root, 1, "/");
            rootFolder = `${root}/${rootFolderLocation}`;
            var search = `${rootFolder}/**/*env.${envType}.json`;
            var files = globSearch.sync(search,rootFolder);
            file = files[0];
            if(file === undefined){
                root = tools.removeBackwardSlashSection(root, 1, "/");
                rootFolder = `${root}/${rootFolderLocation}`;
                var search = `${rootFolder}/**/*env.${envType}.json`;
                var files = globSearch.sync(search,rootFolder);
                file = files[0];
                if(file === undefined){
                    console.log(`could not find file - ${rootFolder}/env.${envType}.json`);
                    throw error(`could not find file - ${rootFolder}/env.${envType}.json`);
                }

            }
        
        }
        
        return {
            file: file,
            rootFolder : root
        };
    }

    useSqlite(rootFolderLocation){
        try{
            this.isSQLite = true;
            var root =  process.cwd();
            var envType = this.__environment;
            var contextName = this.__name;
            var file = this.__findSettings(root, rootFolderLocation, envType);
            var settings = require(file.file);
            var options = settings[contextName];
            
            if(options === undefined){
                console.log("settings missing context name settings");
                throw error("settings missing context name settings");
            }

            this.validateSQLiteOptions(options);
            options.completeConnection = `${file.rootFolder}${options.connection}`;
            var dbDirectory = options.completeConnection.substr(0, options.completeConnection.lastIndexOf("\/"));
            
            if (!fs.existsSync(dbDirectory)){
                fs.mkdirSync(dbDirectory);
            }

            this.db = this.__SQLiteInit(options,  "better-sqlite3");
            this._SQLEngine.setDB(this.db, "better-sqlite3");
            return this;
        }
        catch(err){
            console.log("error:",err );
            throw error(err);
        }
    }

    validateSQLiteOptions(options){
        if(options.hasOwnProperty('connect') === undefined){
            console.log("connnect string settings is missing")
            throw error("connection string settings is missing");
        }

    }
    
    useMySql(rootFolderLocation){
        
            this.isMySQL = true;
            var envType = this.__environment;
            var contextName = this.__name;
            var root = appRoot.path;
            var file = this.__findSettings(root, rootFolderLocation, envType);
            var settings = require(file.file);
            var options = settings[contextName];
            
            if(options === undefined){
                console.log("settings missing context name settings");
                throw error("settings missing context name settings");
            }

            this.db = this.__mysqlInit(options, "mysql2");
            this._SQLEngine.setDB(this.db, "mysql");
            return this;
       
    }


    dbset(model, name){
        var validModel = modelBuilder.create(model);
        validModel.__name = name === undefined ? model.name : name;
        this.__entities.push(validModel); // model object
        var buildMod = tools.createNewInstance(validModel, query, this);
        this.__builderEntities.push(buildMod); // query builder entites
        this[validModel.__name] = buildMod;
    }

    modelState(){
        return this._isModelValid;
    }

    saveChanges(){
        try{
            var tracked = this.__trackedEntities;

            if(tracked.length > 0){
                // start transaction
                if(this.isSQLite){
                    this._SQLEngine.startTransaction();
                    for (var model in tracked) {
                        var currentModel = tracked[model];
                            switch(currentModel.__state) {
                                case "insert": 
                                    var insert = new insertManager(this._SQLEngine, this._isModelValid, this.__entities);
                                    insert.init(currentModel);
                                    
                                break;
                                case "modified":
                                    if(currentModel.__dirtyFields.length > 0){
                                        var cleanCurrentModel = tools.removePrimarykeyandVirtual(currentModel, currentModel._entity); 
                                        // build columns equal to value string 
                                        var argu = this._SQLEngine._buildSQLEqualTo(cleanCurrentModel);
                                        if(argu !== -1 ){
                                            var primaryKey  = tools.getPrimaryKeyObject(cleanCurrentModel.__entity);
                                            var sqlUpdate = {tableName: cleanCurrentModel.__entity.__name, arg: argu, primaryKey : primaryKey, primaryKeyValue : cleanCurrentModel[primaryKey] };
                                            this._SQLEngine.update(sqlUpdate);
                                        }
                                        else{
                                            console.log("Nothing has been tracked, modified, created or added");
                                        }
                                        
                                    }
                                    else{
                                        console.log("Tracked entity modified with no values being changed");
                                    }

                                // code block
                                break;
                                case "delete":
                                    var deleteObject = new deleteManager(this._SQLEngine, this.__entities);
                                    deleteObject.init(currentModel);
                                    
                                break;
                            } 
                    }
                    this.__clearErrorHandler();
                    this._SQLEngine.endTransaction();
                }
                if(this.isMySQL){
                    //this._SQLEngine.startTransaction();
                    for (var model in tracked) {
                        var currentModel = tracked[model];
                            switch(currentModel.__state) {
                                case "insert": 
                                    var insert = new insertManager(this._SQLEngine, this._isModelValid, this.__entities);
                                    insert.init(currentModel);
                                    
                                break;
                                case "modified":
                                    if(currentModel.__dirtyFields.length > 0){
                                        var cleanCurrentModel = tools.removePrimarykeyandVirtual(currentModel, currentModel._entity);
                                        // build columns equal to value string 
                                        var argu = this._SQLEngine._buildSQLEqualTo(cleanCurrentModel);
                                        if(argu !== -1 ){
                                            var primaryKey  = tools.getPrimaryKeyObject(cleanCurrentModel.__entity);
                                            var sqlUpdate = {tableName: cleanCurrentModel.__entity.__name, arg: argu, primaryKey : primaryKey, primaryKeyValue : cleanCurrentModel[primaryKey] };
                                            this._SQLEngine.update(sqlUpdate);
                                        }
                                        else{
                                            console.log("Nothing has been tracked, modified, created or added");
                                        }
                                       
                                    }
                                    else{
                                        console.log("Tracked entity modified with no values being changed");
                                    }

                                // code block
                                break;
                                case "delete":
                                    var deleteObject = new deleteManager(this._SQLEngine, this.__entities);
                                    deleteObject.init(currentModel);
                                    
                                break;
                            } 
                    }
                    this.__clearErrorHandler();
                    //this._SQLEngine.endTransaction();
                }
            }
            else{
                console.log("save changes has no tracked entities");
            }
        }
        
        catch(error){
            this.__clearErrorHandler();
            
            console.log("error", error);
            if(this.isSQLite){
                this._SQLEngine.errorTransaction();
            }
            this.__clearTracked();
            throw error;
        }
       
        this.__clearTracked();
        return true;
    }


    _execute(query){
        this._SQLEngine._execute(query);
    }

    // __track(model){
    //     this.__trackedEntities.push(model);
    //     return model;
    // }

    __track(model){
        var add = true;
        for (var mod in this.__trackedEntities) {
            var id = this.__trackedEntities[mod].__ID;
            if(id === undefined){
                id = Math.floor((Math.random() * 100000) + 1);
            }
            if(id === model.__ID){
                add = false;
            }
        }
        if(this.__trackedEntities.length === 0){
            this.__trackedEntities.push(model);
        }
        else{
            if(add){
                this.__trackedEntities.push(model);
            }
        }

        return model;
    }

    __findTracked(id){
        if(id){
            for (var model in this.__trackedEntities) {
                if(this.__trackedEntities[model].__ID === id){
                    return this.__trackedEntities[model];
                }
            }
        }
        return null;
    }

    __clearTracked(){
        this.__trackedEntities = [];
    }
}


module.exports = context;
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/context.js **
// version 0.0.2
var tools =  require('./Tools');
class DeleteManager{
    constructor(sqlEngine, entities){
        this._SQLEngine = sqlEngine;
        this._allEntities = entities;
    }

    init(currentModel){
        var $that = this;
        try{
           this.cascadeDelete(currentModel);
        }
        catch(error){
            throw error;
        }
    }

    cascadeDelete(currentModel){
        var $that = this;
        if(!Array.isArray(currentModel)){
            const entityKeys = Object.keys(currentModel.__entity);
            // loop though all entity properties
            for (const property of entityKeys) {
                // cascade delete
                if(currentModel.__entity[property].type === "hasOne" || currentModel.__entity[property].type === "hasMany"){
                    var curModel = currentModel[property];
                    if(curModel === null){
                     // check if state is nullable - if so and nothing comes back dont call cascadeDelete
                     var prp = currentModel.__entity[property];
                     if(!prp.nullable){
                        throw "No relationship record found - please set hasOne or hasMany to nullable. "
                     }
                    }
                    else{
                        $that.cascadeDelete( currentModel[property]);
                    }
                }
            }
            this._SQLEngine.delete(currentModel);
        }
        else{

            for(let i = 0 ; i < currentModel.length; i++) {
                const entityKeys = Object.keys(currentModel[i].__entity);
                // loop though all entity properties
                for (const property of entityKeys) {
                    // cascade delete
                    if(currentModel[i].__entity[property].type === "hasOne" || currentModel[i].__entity[property].type === "hasMany"){
                        $that.cascadeDelete( currentModel[i][property]);
                    }
                }
                this._SQLEngine.delete(currentModel[i]);
            }
        }
        

    }
}

module.exports = DeleteManager;
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/deleteManager.js **

// version 0.0.10
var tools =  require('./Tools');
var queryScript = require('masterrecord/QueryLanguage/queryScript');

class InsertManager {

    constructor(sqlEngine, errorModel, allEntities ){
        this._SQLEngine = sqlEngine;
        this._errorModel = errorModel;
        this._allEntities = allEntities;
        this.__queryObject = new queryScript();
    }

    init(currentModel){
        this.runQueries(currentModel);
    }

    runQueries(currentModel){
        var $that = this;
        var cleanCurrentModel = tools.clearAllProto(currentModel);
        this.validateEntity(cleanCurrentModel, currentModel, currentModel.__entity);
        if(this._errorModel.isValid){
            
                var modelEntity = currentModel.__entity;
                // TODO: if you try to add belongs to you must have a tag added first. if you dont throw error
                currentModel = this.belongsToInsert(currentModel, modelEntity);
                var SQL = this._SQLEngine.insert(cleanCurrentModel);
                var primaryKey = tools.getPrimaryKeyObject(currentModel.__entity);
                // return all fields that have auto and dont have a value to the current model on insert
                if(currentModel.__entity[primaryKey].auto === true){
                    var query = `select * from ${currentModel.__entity.__name} where ${primaryKey} = ${ SQL.id }`;
                    var jj = this.__queryObject.raw(query);
                    var getQueryModel = this._SQLEngine.get(jj, currentModel.__entity, currentModel.__context );
                    var idVal;

                    if(!getQueryModel[0]){
                        idVal = getQueryModel[primaryKey]
                    }
                    else{
                        idVal =  getQueryModel[0][primaryKey];
                    }
                   
                    currentModel[primaryKey] = idVal;
                }

                const proto = Object.getPrototypeOf(currentModel);
                const props = Object.getOwnPropertyNames(proto);
                const cleanPropList = tools.returnEntityList(props, modelEntity);
                const modelKeys = Object.keys(currentModel);
                const mergedArray =  [...new Set(modelKeys.concat(cleanPropList))];
                // loop through model properties
                for (const property of mergedArray) {
                    var propertyModel = currentModel[property];
                    var entityProperty = modelEntity[property] ? modelEntity[property] : {};
                    if(entityProperty.type === "hasOne"){
                        // make sure property model is an object not a primary data type like number or string
                     
                        if(typeof(propertyModel) === "object" || typeof(propertyModel) === "function" ){
                            // check if model has its own entity
                            if(modelEntity){
                                // check if property has a value because we dont want this to run on every insert if nothing was added
                                propertyModel.__entity = tools.getEntity(property, $that._allEntities);
                                propertyModel[currentModel.__entity.__name] = SQL.id;
                                $that.runQueries(propertyModel);
                            }
                            else{
                                throw `Relationship "${entityProperty.name}" could not be found please check if object has correct spelling or if it has been added to the context class`
                            }
                        }
                    }
                    
                    if(entityProperty.type === "hasMany"){
                        if(tools.checkIfArrayLike(propertyModel)){
                            const propertyKeys = Object.keys(propertyModel);
                            for (const propertykey of propertyKeys) {
                                if(propertyModel[propertykey]){
                                    propertyModel[propertykey].__entity = tools.getEntity(property, $that._allEntities);
                                    propertyModel[propertykey][currentModel.__entity.__name] = SQL.id;
                                    $that.runQueries(propertyModel[propertykey]);
                                }
                            }
                        }
                        else{
                            throw `Relationship "${entityProperty.name}" must be an array`;
                        }
                    }

                }
        }
        else{
            var messages = this._errorModel.errors;
            const combinedError = messages.join('; and ');
            throw combinedError;

        }
    }

    

    // will insert belongs to row first and return the id so that next call can be make correctly
    belongsToInsert(currentModel, modelEntity){
        var $that = this;
        for(var entity in modelEntity) {
            if(modelEntity[entity].relationshipType === "belongsTo"){
                var foreignKey = modelEntity[entity].foreignKey === undefined ? modelEntity[entity].name : modelEntity[entity].foreignKey;
                var newPropertyModel = currentModel[foreignKey];
                // check if model is a an object. If so insert the child first then the parent. 
                if(typeof newPropertyModel === 'object'){
                    newPropertyModel.__entity = tools.getEntity(entity, $that._allEntities);
                    var propertyCleanCurrentModel = tools.clearAllProto(newPropertyModel);
                    this.validateEntity(propertyCleanCurrentModel, newPropertyModel, newPropertyModel.__entity);
                    var propertySQL = this._SQLEngine.insert(newPropertyModel);
                    currentModel[foreignKey] = propertySQL.id; 
                }
            }
        }
        // todo:
            // loop through all modelEntity and find all the belongs to
            // if belongs to is true then make sql call to insert
            // update the currentModel.
        return currentModel;
    }

    // validate entity for nullable fields and if the entity has any values at all
    validateEntity(currentModel, currentRealModel, entityModel){
        for(var entity in entityModel) {
            var currentEntity = entityModel[entity];
            if (entityModel.hasOwnProperty(entity)) {
                // check if there is a default value
                if(currentEntity.default){
                    if(currentRealModel[entity] === undefined || currentRealModel[entity] === null){
                        // if its empty add the default value
                        currentRealModel[entity] = currentEntity.default;
                    }
                }
            
                // SKIP belongs too -----   // call sets for correct data for DB
                if(currentEntity.type !== "belongsTo" && currentEntity.type !== "hasMany"){
                    if(currentEntity.relationshipType !== "belongsTo"){
                        // primary is always null in an insert so validation insert must be null
                        if(currentEntity.nullable === false && !currentEntity.primary){
                            // if it doesnt have a get method then call error
                            if(currentEntity.set === undefined){
                                if(currentModel[entity] === undefined || currentModel[entity] === null ){
                                    this._errorModel.isValid = false;
                                    var errorMessage = `Entity ${currentModel.__entity.__name} column ${entity} is a required Field`;
                                    this._errorModel.errors.push(errorMessage);
                                    //throw errorMessage;
                                }
                            }
                            else{
                                var realData = currentEntity.set(currentModel[entity]);
                                currentRealModel[entity] = realData;
                                currentModel[entity] = realData;
                            }
                        }
                    }
                   
                }
            }

        }
    }
    
}


module.exports = InsertManager;

** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/insertManager.js **
// version : 0.0.3

var tools =  require('masterrecord/Tools');
var util = require('util');

class SQLLiteEngine {

    unsupportedWords = ["order"]

    update(query){
        var sqlQuery = ` UPDATE ${query.tableName} SET ${query.arg} WHERE ${query.tableName}.${query.primaryKey} = ${query.primaryKeyValue}` // primary key for that table = 
        return this._run(sqlQuery);
    }

    delete(queryObject){
       var sqlObject = this._buildDeleteObject(queryObject);
       var sqlQuery = `DELETE FROM ${sqlObject.tableName} WHERE ${sqlObject.tableName}.${sqlObject.primaryKey} = ${sqlObject.value}`;
       return this._run(sqlQuery);
    }

    insert(queryObject){
        var sqlObject = this._buildSQLInsertObject(queryObject, queryObject.__entity);
        var query = `INSERT INTO ${sqlObject.tableName} (${sqlObject.columns}) VALUES (${sqlObject.values})`;
        var queryObj = this._run(query);
        // return 
        var open = {
            "id": queryObj.insertId
        };
        return open;
    }

    get(query, entity, context){
        var queryString = {};
        try {
            if(query.raw){
                queryString.query = query.raw;
            }
            else{
                queryString = this.buildQuery(query, entity, context);
            }
            if(queryString.query){
                console.log("SQL:", queryString.query);
                this.db.connect(this.db);
                const result = this.db.query(queryString.query);
                console.log("results:", result);
                return result;
            }
            return null;
        } catch (err) {
            console.error(err);
            return null;
        }
    }

    getCount(queryObject, entity, context){
        var query = queryObject.script;
        var queryString = {};
        try {
            if(query.raw){
                queryString.query = query.raw;
            }
            else{
                queryString = this.buildQuery(query, entity, context);
            }
            if(queryString.query){
                var queryCount = queryObject.count(queryString.query)
                console.log("SQL:", queryCount );
                var queryReturn = this.db.prepare(queryCount ).get();
                return queryReturn;
            }
            return null;
        } catch (err) {
            console.error(err);
            return null;
        }
    }

    all(query, entity, context){
        var queryString = {};
        try {
            if(query.raw){
                queryString.query = query.raw;
            }
            else{
                queryString = this.buildQuery(query, entity, context);
            }
            if(queryString.query){
                console.log("SQL:", queryString.query);
                this.db.connect(this.db);
                const result = this.db.query(queryString.query);
                console.log("results:", result);
                return result;
            }
            return null;
        } catch (err) {
            console.error(err);
            return null;
        }
    }


    buildQuery(query, entity, context){

        var queryObject = {};
        if(entity){
            queryObject.entity = this.getEntity(entity.__name, query.entityMap);
            queryObject.select = this.buildSelect(query, entity);
            queryObject.from = this.buildFrom(query, entity);
            queryObject.include = this.buildInclude(query, entity, context, queryObject);
            queryObject.where = this.buildWhere(query, entity);
    
            var queryString = `${queryObject.select} ${queryObject.from} ${queryObject.include} ${queryObject.where}`;
            return { 
                    query : queryString,
                    entity : this.getEntity(entity.__name, query.entityMap)
            }
        }
        else{
            console.log("Error: Entity object is blank");
        }
       

    }

    buildWhere(query, mainQuery){
        var whereEntity = query.where;
        var strQuery = "";
        var $that = this;
        if(whereEntity){
            var entity = this.getEntity(query.parentName, query.entityMap);
            for (let part in whereEntity[query.parentName]) {
                    var item = whereEntity[query.parentName][part];
                    for (let exp in item.expressions) {
                        var field = tools.capitalizeFirstLetter(item.expressions[exp].field);
                        if(mainQuery[field]){
                            if(mainQuery[field].isNavigational){
                                entity = $that.getEntity(field, query.entityMap);
                                field = item.fields[1];
                            }
                        }
                        if(strQuery === ""){
                            strQuery = `WHERE ${entity}.${field}  ${item.expressions[exp].func} '${item.expressions[exp].arg}'`;
                        }
                        else{
                            strQuery = `${strQuery} and ${entity}.${field}  ${item.expressions[exp].func} '${item.expressions[exp].arg}'`;
                        }
                    }
                }
        }
        return strQuery;
    }

    buildInclude( query, entity, context){
        var includeQuery =  "";
        for (let part in query.include) {
            var includeEntity = query.include[part];
            var $that = this;
            if(includeEntity){
                var parentObj = includeEntity[query.parentName];
                var currentContext = "";
                if(includeEntity.selectFields){
                    currentContext = context[tools.capitalizeFirstLetter(includeEntity.selectFields[0])];
                }
                
                if(parentObj){
                    parentObj.entityMap = query.entityMap;
                    var foreignKey = $that.getForeignKey(entity.__name, currentContext.__entity);
                    var mainPrimaryKey = $that.getPrimarykey(entity);
                    var mainEntity = $that.getEntity(entity.__name, query.entityMap);
                    if(currentContext.__entity[entity.__name].type === "hasManyThrough"){
                        var foreignTable = tools.capitalizeFirstLetter(currentContext.__entity[entity.__name].foreignTable); //to uppercase letter
                        foreignKey = $that.getPrimarykey(currentContext.__entity);
                        mainPrimaryKey = context[foreignTable].__entity[currentContext.__entity.__name].foreignKey;
                        var mainEntity = $that.getEntity(foreignTable,query.entityMap);
                    }
                    // add foreign key to select so that it picks it up
                    if(parentObj.select){
                        parentObj.select.selectFields.push(foreignKey);
                    }else{
                        parentObj.select = {};
                        parentObj.select.selectFields = [];
                        parentObj.select.selectFields.push(foreignKey);
                    }

                    var innerQuery = $that.buildQuery(parentObj, currentContext.__entity, context);

                    includeQuery += `LEFT JOIN (${innerQuery.query}) AS ${innerQuery.entity} ON ${ mainEntity}.${mainPrimaryKey} = ${innerQuery.entity}.${foreignKey} `;

                }
            }
        }
        return includeQuery;
    }

    buildFrom(query, entity){
        var entityName = this.getEntity(entity.__name, query.entityMap);
        if(entityName ){
            return `FROM ${entity.__name } AS ${entityName}`;
        }
        else{ return "" }
    }

    buildSelect(query, entity){
        // this means that there is a select statement
        var select = "SELECT";
        var arr = "";
        var $that = this;
        if(query.select){
            for (const item in query.select.selectFields) {
                arr += `${$that.getEntity(entity.__name, query.entityMap)}.${query.select.selectFields[item]}, `;
            };
          
        }
        else{
            var entityList = this.getEntityList(entity);
            for (const item in entityList) {
                arr += `${$that.getEntity(entity.__name, query.entityMap)}.${entityList[item]}, `;
            };
        }
        arr = arr.replace(/,\s*$/, "");
        return `${select} ${arr} `;
    }

    getForeignKey(name, entity){
        if(entity && name){
           return entity[name].foreignKey;
        }
    }

    getPrimarykey(entity){
            for (const item in entity) {
                if(entity[item].primary){
                    if(entity[item].primary === true){
                        return entity[item].name;
                    }
                }
            };
    }

    getForeignTable(name, entity){
        if(entity && name){
           return entity[name].foreignTable;
        }
    }

    getInclude(name, query){
        var include = query.include;
        if(include){
            for (let part in include) {
                if(tools.capitalizeFirstLetter(include[part].selectFields[0]) === name){
                    return include[part];
                }
            }
        }
        else{
            return "";
        }
    }

    getEntity(name, maps){
        for (let item in maps) {
            var map = maps[item];
            if(tools.capitalizeFirstLetter(name) === map.name){
                return map.entity
            }
        }
        return "";
    }

    // return a list of entity names and skip foreign keys and underscore.
    getEntityList(entity){
        var entitiesList = [];
        var $that = this;
        for (var ent in entity) {
                if(!ent.startsWith("_")){
                    if(!entity[ent].foreignKey){
                        if(entity[ent].relationshipTable){
                            if($that.chechUnsupportedWords(entity[ent].relationshipTable)){
                                entitiesList.push(`'${entity[ent].relationshipTable}'`);
                            }
                            else{
                                entitiesList.push(entity[ent].relationshipTable);
                            }
                        }
                        else{
                            if($that.chechUnsupportedWords(ent)){
                                entitiesList.push(`'${ent}'`);
                            }
                            else{
                                entitiesList.push(ent);
                            }
                        }
                    }
                    else{
                        
                        if(entity[ent].relationshipType === "belongsTo"){
                            var name = entity[ent].foreignKey;
                            if($that.chechUnsupportedWords(name)){
                                entitiesList.push(`'${name}'`);
                                //entitiesList.push(`'${ent}'`);
                            }
                            else{
                                entitiesList.push(name);
                                //entitiesList.push(ent);
                            }
                        }
                        
                    }
                }
            }
        return entitiesList
    }

    chechUnsupportedWords(word){
        for (var item in this.unsupportedWords) {
            var text = this.unsupportedWords[item];
            if(text === word){
                return true
            }
        }
        return false;
    }

    startTransaction(){
        this.db.prepare('BEGIN').run();
    }

    endTransaction(){
        this.db.prepare('COMMIT').run();
    }

    errorTransaction(){
        this.db.prepare('ROLLBACK').run();
    }

    _buildSQLEqualTo(model){
        var $that = this;
        var argument = null;
        var dirtyFields = model.__dirtyFields;
        
        for (var column in dirtyFields) {
            // TODO Boolean value is a string with a letter
            var type = model.__entity[dirtyFields[column]].type;
            
            if(model.__entity[dirtyFields[column]].relationshipType === "belongsTo"){
                type = "belongsTo";
            }

            switch(type){
                case "belongsTo" :
                    const foreignKey = model.__entity[dirtyFields[column]].foreignKey;
                    argument = `${foreignKey} = ${model[dirtyFields[column]]},`;
                break;
                case "integer" :
                    const columneValue = model[`_${dirtyFields[column]}`];
                    argument = argument === null ? `[${dirtyFields[column]}] = ${model[dirtyFields[column]]},` : `${argument} [${dirtyFields[column]}] = ${columneValue},`;
                break;
                case "string" :
                    argument = argument === null ? `${dirtyFields[column]} = '${$that._santizeSingleQuotes(model[dirtyFields[column]])}',` : `${argument} ${dirtyFields[column]} = '${$that._santizeSingleQuotes(model[dirtyFields[column]])}',`;
                break;
                case "boolean" :
                    argument = argument === null ? `${dirtyFields[column]} = '${this.boolType(model[dirtyFields[column]])}',` : `${argument} ${dirtyFields[column]} = '${this.boolType(model[dirtyFields[column]])}',`;
                break;
                default:
                    argument = argument === null ? `${dirtyFields[column]} = '${model[dirtyFields[column]]}',` : `${argument} ${dirtyFields[column]} = '${model[dirtyFields[column]]}',`;
            }
        }
       if(argument){
            return argument.replace(/,\s*$/, "");
        }
        else{
            return -1;
        }
    }

    boolType(type){
        var jj = String(type);
        switch(jj) {
            case "true":
                return 1
              break;
              case "false":
                return 0
              break;
              default:
                return type;
        }
    }

    
    _buildDeleteObject(currentModel){
        var primaryKey = currentModel.__Key === undefined ? tools.getPrimaryKeyObject(currentModel.__entity) : currentModel.__Key;
        var value = currentModel.__value === undefined ? currentModel[primaryKey] : currentModel.__value;
        var tableName = currentModel.__tableName === undefined ? currentModel.__entity.__name : currentModel.__tableName;
        return {tableName: tableName, primaryKey : primaryKey, value : value};
    }


       // return columns and value strings
    _buildSQLInsertObject(fields, modelEntity){
        var $that = this;
        var columns = null;
        var values = null;
        for (var column in modelEntity) {
            // column1 = value1, column2 = value2, ...
            if(column.indexOf("__") === -1 ){
                // call the get method if avlable
                var fieldColumn = "";
                // check if get function is avaliable if so use that
                fieldColumn = fields[column];       

                if((fieldColumn !== undefined && fieldColumn !== null) && typeof(fieldColumn) !== "object"){
                    switch(modelEntity[column].type){
                        case "string" : 
                            fieldColumn = `'${$that._santizeSingleQuotes(fields[column])}'`;
                        break;
                        case "time" : 
                            fieldColumn = fields[column];
                        break;
                    }
                    
                    var relationship = modelEntity[column].relationshipType
                    if(relationship === "belongsTo"){
                        column = modelEntity[column].foreignKey
                    }


                    columns = columns === null ? `${column},` : `${columns} ${column},`;
                    values = values === null ? `${fieldColumn},` : `${values} ${fieldColumn},`;

                }
            }
        }

        return {tableName: modelEntity.__name, columns: columns.replace(/,\s*$/, ""), values: values.replace(/,\s*$/, "")};

    }

    // will add double single quotes to allow sting to be saved.
    _santizeSingleQuotes(string){

        if(typeof string === "string"){
            return string.replace(/'/g, "''");
        }else{
            return `${string}`;
        }
    }

    // converts any object into SQL parameter select string
    _convertEntityToSelectParameterString(obj, entityName){
        // todo: loop throgh object and append string with comma to 
        var mainString = "";
        const entries = Object.keys(obj);

        for (const [name] of entries) {
         mainString += `${mainString}, ${entityName}.${name}`;
        }
        return mainString;;
    }

    _execute(query){
        console.log("SQL:", query);
        this.db.connect(this.db);
        return this.db.query(query);
    }

     _run(query){
        try{        
            
            console.log("SQL:", query);
            this.db.connect(this.db);
            const result = this.db.query(query);
    
            return result;}
        catch (error) {
            console.error(error);
            // Expected output: ReferenceError: nonExistentFunction is not defined
            // (Note: the exact output may be browser-dependent)
          }
    }

    setDB(db, type){
       this.db = db;
       this.dbType = type; // this will let us know which type of sqlengine to use.
   }
}

module.exports = SQLLiteEngine;




/***
 * 
 * 
 * 
 * const mysql = require('mysql2/promise');

class MySQLClient {
    constructor(config) {
        this.config = config;
        this.pool = mysql.createPool(config);
    }

    async query(sql, params = []) {
        const connection = await this.pool.getConnection();
        try {
            const [results] = await connection.execute(sql, params);
            return results;
        } finally {
            connection.release();
        }
    }

    async close() {
        await this.pool.end();
    }
}

module.exports = MySQLClient;

 */
** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/mySQLEngine.js **
var MySql = require('sync-mysql2');


class MySQLClient {
    constructor(config) {
        this.config = config;
        this.connection = null;
    }

    connect() {
        if (!this.connection) {
            this.connection = new MySql(this.config);
        }
    }

    query(sql, params = []) {
        try {
            if (!this.connection) {
                throw new Error('Database connection not established. Call connect() first.');
            }
            var jj = this.connection.query(sql);
            this.connection.finishAll();
            return jj;
        } catch (err) {
            console.error(err);
            return null;
        }

    }

    close() {
        if (this.connection) {
            this.connection.end();
            this.connection = null;
        }
    }
}

module.exports = MySQLClient;

** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/mySQLSyncConnect.js **
{
  "name": "masterrecord",
  "dependencies": {
    "commander": "^13.1.0",
    "glob" : "^11.0.1",
    "deep-object-diff" : "^1.1.9",
    "pg" : "^8.14.1",
    "sync-mysql2" : "^1.0.5",
    "app-root-path": "^3.1.0"
  },
  "version": "0.1.4",
  "description": "An Object-relational mapping for the Master framework. Master Record connects classes to relational database tables to establish a database with almost zero-configuration ",
  "homepage": "https://github.com/Tailor/MasterRecord#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Tailor/Masterrecord.git"
  },
  "main": "MasterRecord.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Alexander Rich",
  "license": "ISC",
  "bin": {
    "masterrecord": "./migrations/cli.js"
  }
}

** LOCATION: /Users/alexanderrich/Documents/development/MasterRecord/package.json **
