

# MasterRecord

MasterRecord is a lightweight, code-first ORM and migration tool for Node.js with a fluent query API. It lets you define entities in JavaScript, generate migrations, and query with expressive syntax.

- Supported databases: MySQL, SQLite
- Synchronous API by default (no await needed)
- Built-in CLI for migrations and seeding

## Installation

```bash
# npm
npm install masterrecord

# pnpm
pnpm add masterrecord

# yarn
yarn add masterrecord
```

## Quick Start

1) Create an environment config file (see Environment below), then enable migrations:

```bash
npx masterrecord enable-migrations AppContext
```

2) Make or change your entities, then create a migration file:

```bash
npx masterrecord add-migration Init AppContext
```

3) Apply the migration to your database:

```bash
master=development npx masterrecord update-database AppContext
```

### Enable migrations (one-time per Context)

- Run from the project root where your Context file lives. Use the Context file name (without extension) as the argument.
```bash
master=development masterrecord enable-migrations AppContext
```
This creates `db/migrations/<context>_contextSnapShot.json` and the `db/migrations` directory.

### Create a migration

- After you change your entity models, generate a migration file:
```bash
master=development masterrecord add-migration <MigrationName> AppContext
```
This writes a new file to `db/migrations/<timestamp>_<MigrationName>_migration.js`.

###  Apply migrations to the database

- Apply only the latest pending migration:
```bash
master=development masterrecord update-database AppContext
```
- Apply all migrations from the beginning (useful for a clean DB):
```bash
master=development masterrecord update-database-restart AppContext
```
- List migration files (debug/inspection):
```bash
master=development masterrecord get-migrations AppContext
```

Notes:
- The CLI searches for `<context>_contextSnapShot.json` under `db/migrations` relative to your current working directory.
- For MySQL, ensure your credentials allow DDL. For SQLite, the data directory is created if missing.

### Updating the running server

General flow to roll out schema changes:
- Stop the server or put it into maintenance mode (optional but recommended for non-backward-compatible changes).
- Pull the latest code (containing updated models and generated migration files).
- Run migrations against the target environment:
```bash
master=production masterrecord update-database AppContext
```
- Restart your server/process manager (e.g., `pm2 restart <app>`, `docker compose up -d`, or your platform’s restart command).

Backward-compatible rollout tip:
- If possible, deploy additive changes first (new tables/columns), release app code that begins using them, then later clean up/removal migrations.

### Troubleshooting

- Cannot find Context file: ensure you run commands from the app root and pass the correct Context file name used when defining your class (case-insensitive in the snapshot, but supply the same name you used).
- Cannot connect to DB: confirm `master=<env>` is set and `env.<env>.json` exists with correct credentials and paths.
- MySQL type mismatches: the migration engine maps MasterRecord types to SQL types; verify your entity field `type` values are correct.

### Recent improvements (2025-09)

- Query language and SQL engines:
  - Correct parsing of multi-char operators (>=, <=, ===, !==) and spaced logical operators.
  - Support for grouped OR conditions rendered as parenthesized OR in WHERE across SQLite/MySQL.
  - Resilient fallback for partially parsed expressions.
- Relationships:
  - `hasManyThrough` supported in insert and delete cascades.
- Environment file discovery:
  - Context now walks up directories to find `config/environments/env.<env>.json`; fixed error throwing.
- Migrations (DDL generation):
  - Default values emitted for SQLite/MySQL (including boolean coercion).
  - `CREATE TABLE IF NOT EXISTS` to avoid failures when rerunning.
  - Table introspection added; existing tables are synced: missing columns are added, MySQL applies `ALTER ... MODIFY` for NULL/DEFAULT changes, SQLite rebuilds table when necessary.
- Migration API additions in `schema.js`:
  - `renameColumn(table)` implemented for SQLite/MySQL.
  - `seed(tableName, rows)` implemented for bulk/single inserts with safe quoting.

### Using renameColumn and seed in migrations

Basic migration skeleton (generated by CLI):
```js
var masterrecord = require('masterrecord');

class AddSettings extends masterrecord.schema { 
  constructor(context){ super(context); }

  up(table){
    this.init(table);
    // Add a new table
    this.createTable(table.MailSettings);

    // Rename a column on an existing table
    this.renameColumn({ tableName: 'MailSettings', name: 'from_email', newName: 'reply_to' });

    // Seed initial data (single row)
    this.seed('MailSettings', {
      from_name: 'System',
      reply_to: 'no-reply@example.com',
      return_path_matches_from: 0,
      weekly_summary_enabled: 0,
      created_at: Date.now(),
      updated_at: Date.now()
    });

    // Seed multiple rows
    this.seed('MailSettings', [
      { from_name: 'Support', reply_to: 'support@example.com', created_at: Date.now(), updated_at: Date.now() },
      { from_name: 'Marketing', reply_to: 'marketing@example.com', created_at: Date.now(), updated_at: Date.now() }
    ]);
  }

  down(table){
    this.init(table);
    // Revert the rename
    this.renameColumn({ tableName: 'MailSettings', name: 'reply_to', newName: 'from_email' });

    // Optionally clean up seeded rows
    // this.context._execute("DELETE FROM MailSettings WHERE reply_to IN ('no-reply@example.com','support@example.com','marketing@example.com')");

    // Drop table if that was part of up
    // this.dropTable(table.MailSettings);
  }
}
module.exports = AddSettings;
```

Notes:
- `renameColumn` expects an object: `{ tableName, name, newName }` and works in both SQLite and MySQL.
- `seed(tableName, rows)` accepts:
  - a single object: `{ col: value, ... }`
  - or an array of objects: `[{...}, {...}]`
  Values are auto-quoted; booleans become 1/0.
- When a table already exists, `update-database` will sync schema:
  - Add missing columns.
  - MySQL: adjust default/nullability via `ALTER ... MODIFY`.
  - SQLite: rebuilds the table when nullability/default/type changes require it.

### Tips
- Prefer additive changes (add columns) before destructive changes (drops/renames) to minimize downtime.
- For large SQLite tables, a rebuild copies data; consider maintenance windows.
- Use `master=development masterrecord get-migrations AppContext` to inspect migration order.

## Multi-context (multi-database) projects

When your project defines multiple Context files (e.g., `userContext.js`, `modelContext.js`, `mailContext.js`, `chatContext.js`) across different packages or feature directories, MasterRecord can auto-detect and operate on all of them.

### New bulk commands

- enable-migrations-all (alias: ema)
  - Scans the project for MasterRecord Context files (heuristic) and enables migrations for each by writing a portable snapshot next to the context at `<ContextDir>/db/migrations/<context>_contextSnapShot.json`.

- add-migration-all <Name> (alias: ama)
  - Creates a migration named `<Name>` (e.g., `Init`) for every detected context that has a snapshot. Migrations are written into each context’s own migrations folder.

- update-database-all (alias: uda)
  - Applies the latest migration for every detected context with migrations.

- update-database-down <ContextName> (alias: udd)
  - Runs the latest migration’s `down()` for the specified context.

- update-database-target <migrationFileName> (alias: udt)
  - Rolls back migrations newer than the given migration file within that context’s migrations folder.

- ensure-database <ContextName> (alias: ed)
  - For MySQL contexts, ensures the database exists (like EF’s `Database.EnsureCreated`). Auto-detects connection info from your Context env settings.

### Portable snapshots (no hardcoded absolute paths)

Snapshots are written with relative paths, so moving/renaming the project root does not break CLI resolution:
- `contextLocation`: path from the migrations folder to the Context file
- `migrationFolder`: `.` (the snapshot resides in the migrations folder)
- `snapShotLocation`: the snapshot filename

### Typical flow for multiple contexts

1) Enable migrations everywhere:
```bash
# macOS/Linux
master=development masterrecord enable-migrations-all

# Windows PowerShell
$env:master = 'development'
masterrecord enable-migrations-all
```

2) Create an initial migration for all contexts:
```bash
# macOS/Linux
master=development masterrecord add-migration-all Init

# Windows PowerShell
$env:master = 'development'
masterrecord add-migration-all Init
```

3) Apply migrations everywhere:
```bash
# macOS/Linux
master=development masterrecord update-database-all

# Windows PowerShell
$env:master = 'development'
masterrecord update-database-all
```

4) Inspect migrations for a specific context:
```bash
# macOS/Linux
master=development masterrecord get-migrations userContext

# Windows PowerShell
$env:master = 'development'
masterrecord get-migrations userContext
```

5) Roll back latest for a specific context:
```bash
# macOS/Linux
master=development masterrecord update-database-down userContext

# Windows PowerShell
$env:master = 'development'
masterrecord update-database-down userContext
```

### Environment selection (cross-platform)
- macOS/Linux prefix: `master=development ...` or `NODE_ENV=development ...`
- Windows PowerShell:
```powershell
$env:master = 'development'
masterrecord update-database-all
```
- Windows cmd.exe:
```cmd
set master=development && masterrecord update-database-all
```

### Notes and tips
- Each Context should define its own env settings and tables; `update-database-all` operates context-by-context so separate databases are handled cleanly.
- For SQLite contexts, the `connection` path will be created if the directory does not exist.
- For MySQL contexts, `ensure-database <ContextName>` can create the DB (permissions required) before migrations run.
- If you rename/move the project root, re-run `enable-migrations-all` or any single-context command once; snapshots use relative paths and will continue working.
- If `update-database-all` reports “no migration files found” for a context, run `get-migrations <ContextName>`. If empty, create a migration with `add-migration <Name> <ContextName>` or use `add-migration-all <Name>`.


